---
title: "ns_3Species"
output: html_document
editor_options: 
  chunk_output_type: inline
---

# Log
@20231216 
Ran til temperature and biomass

@20231220
Ran til save an load Rdata
Next: 
0. Continue after Save and load RData
1. Need to find how I compiled the fishing mortality and temperature data and describe or show the code.
2. Already update the partially revised version at github


#---------- data cleaning  -----------------------

# library
```{r}

library(devtools)
library(ggplot2)
library(tidyverse)
library(moments)
library(mapplots)
library(knitr)
library(gridExtra)
library(rfishbase)
library(broom)
library(purrr)
library(corrplot)
library(openxlsx)
library(dplyr)
library(RColorBrewer)
library(lme4)
library(lmerTest)
library(nlme)
library(astsa)
library(car)
library(MuMIn)
library(leaps)
library(viridis)
library(DHARMa)
library(sjPlot)
library(maps)


```


# Read data 
Both raw data files NS_stn_1965_2000, NS_stn_2001_2020 were downloaded from ICES data portal https://data.ices.dk. 
```{r}

# Read data: 
ns.stn.1<-read.csv("~/Dropbox/Academic/Ecoinformatics/a0_FishSpatial_MS/a_spatial_overlap_analysis/data/NS_stn_1965_2000.csv")

ns.stn.2<-read.csv("~/Dropbox/Academic/Ecoinformatics/a0_FishSpatial_MS/a_spatial_overlap_analysis/data/NS_stn_2001_2020.csv")

ns.stn.1$Region <- "North Sea"
ns.stn.2$Region <- "North Sea"

dd.stn <- bind_rows(ns.stn.1, ns.stn.2)

```


# Filter to 3 focal species
```{r}

dd.stn <- dd.stn %>%
  filter(Species %in% c("Gadus morhua","Melanogrammus aeglefinus", "Merlangius merlangus"))

dd.stn <- dd.stn %>% rename(Scientific_Name = Species )

dd.stn <- dd.stn %>% 
    mutate(Species = case_when
           ( Scientific_Name == "Gadus morhua" ~ 'Atlantic cod',
             Scientific_Name == "Melanogrammus aeglefinus" ~ 'Haddock',
             Scientific_Name == "Merlangius merlangus" ~ 'Whiting'
             ))

```

# Clean data and rename 
```{r}

# Remove unnessary columns 
dd.stn <- dd.stn %>%
  select(-c(Survey,Area,AphiaID,DateofCalculation))


# Remove LngtClass = 0 
## Note that CPUE of LngtClass = 0 is always 0
dd.stn <- dd.stn %>%
  filter(LngtClass > 0) 

## Check max and min length 
dd.stn %>%
  group_by(Species, Region) %>%
  summarise(max_length = max(LngtClass),
            min_length = min(LngtClass))

# Remove subareas which CPUE = 0 for each length and time point
dd.stn <- dd.stn %>%
  filter(CPUE_number_per_hour > 0) 

# #--------------Add YearQua-------------------------
dd.stn <- dd.stn %>%
  mutate(YearQua=paste(Year,Quarter,sep="."))

```  
  
# Remove fish with extreme body length
note: there is a typo in Fig S1 caption: the cut offs are 5% and 80%, rather than 5% and 85% quantiles.
```{r}

# create and filter dd.stn.before.cut to plot Fig S1.

dd.stn.before.cut <- dd.stn

dd.stn.before.cut <- dd.stn.before.cut %>% 
   filter(Year >=1977 & Year < 2020) %>% 
   filter(Quarter == "1")

# create tibble q.limit as lower and upper limits. They are 5% and 80% quantiles of body size structure.
q.limit <- dd.stn %>% 
  group_by(Species) %>% 
  summarise(Lower_limit = min(LngtClass) + 
           (0.05 * (max(LngtClass)-min(LngtClass))),
         Upper_limit= min(LngtClass + 
            (0.80 * (max(LngtClass)-min(LngtClass)))))  


# Remove fish whose length is shorter than lower limit and larger than upper limit.
dd.stn <- dd.stn %>% 
  group_by(Species, Region) %>% 
  mutate(Lower_limit = min(LngtClass) + 
           (0.05 * (max(LngtClass)-min(LngtClass))),
         Upper_limit= min(LngtClass + 
            (0.80 * (max(LngtClass)-min(LngtClass))))) %>% 
  filter(LngtClass > Lower_limit & LngtClass < Upper_limit) 
 
```

 
# Filter study period 
```{r}

dd.stn <- dd.stn %>% 
  filter(Year >=1977 & Year < 2020)

dd.stn <- dd.stn %>% 
  filter(Quarter == "1")

dd.stn %>% 
  group_by(Year,Quarter) %>% 
  tally()

```
 
 
# graph settings for plotting graphs later
```{r}

theme <- 
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"),
    #axis.text.x=element_blank(),
    #axis.ticks.x=element_blank(),
    legend.position="none")

```


#----------data preparation ----------------------------

# Create cpue.lngt.subarea.yearqua

```{r}

# Create cpue.lngt.subarea.yearqua
cpue.lngt.subarea.yearqua <-
  dd.stn %>%
  group_by(Region,Species,YearQua,SubArea,LngtClass) %>%
  summarise(CPUE_Lngt_SubArea_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>%
  group_by(Region,Species, YearQua, SubArea) %>% 
  mutate(CPUE_All_Lngt_SubArea_Yearqua = sum(CPUE_Lngt_SubArea_YearQua))

```


# Create cpue.lngt.yearqua

```{r}

cpue.lngt.yearqua <-
  dd.stn %>%
  group_by(Region,Species,YearQua,LngtClass) %>%
  summarise(CPUE_Lngt_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>% 
  # Add CPUE_All_Lngt_Yearqua 
  group_by(Region, Species, YearQua) %>% 
  mutate(CPUE_All_Lngt_Yearqua = sum(CPUE_Lngt_YearQua)) %>% 
  mutate(Denstiy_CPUE_Lngt_Yearqua = 
           CPUE_Lngt_YearQua/CPUE_All_Lngt_Yearqua)

```


# Create cpue.lngt.yearqua for plotting size distribution in Fig S1

```{r}

cpue.lngt.yearqua.before.cut <-
  dd.stn.before.cut %>%
  group_by(Region,Species,YearQua,LngtClass) %>%
  summarise(CPUE_Lngt_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>% 
  # Add CPUE_All_Lngt_Yearqua 
  group_by(Region, Species, YearQua) %>% 
  mutate(CPUE_All_Lngt_Yearqua = sum(CPUE_Lngt_YearQua)) %>% 
  mutate(Denstiy_CPUE_Lngt_Yearqua = 
           CPUE_Lngt_YearQua/CPUE_All_Lngt_Yearqua)


```


# Create cpue.length.subarea.yearqua & cpue.subarea.yearqua
To run sensitivity analysis on different number of body size groups, replace 20 with different numbers.
```{r }

cpue.length.subarea.yearqua <-dd.stn %>% 
  group_by(Region, Species) %>%
  # (Original length class - min class)/ (length range/10)
  mutate(Length=(LngtClass-min(LngtClass)) %/% ((max(LngtClass)-min(LngtClass))/20)) %>%
  filter (Length < 20) %>%
  # Add cpue of all LngtClasses that belong to each Length
  group_by(Region,Species,YearQua,SubArea,Length) %>% 
  summarize(CPUE_Length_Subarea_Yearqua=sum(CPUE_number_per_hour))  

cpue.subarea.yearqua <-cpue.length.subarea.yearqua %>%
  group_by(Region, Species, YearQua, SubArea) %>%
  summarize(CPUE_All_Length_Subarea_Yearqua = sum(CPUE_Length_Subarea_Yearqua))


# Add CPUE_All_Length_Subarea_Yearqua to tibble cpue.length.subarea.yearqua
cpue.length.subarea.yearqua<-cpue.length.subarea.yearqua %>%
  left_join(cpue.subarea.yearqua,by=c("Region","Species", "YearQua", "SubArea"))

# Check how many ind in each Length
cpue.length.subarea.yearqua %>% 
  group_by(Region,Species, Length) %>% 
  tally()

```


# summary of body size bin length
```{r}

dd.stn %>% 
  group_by(Region, Species) %>%
  # (Original length class - min class)/ (length range/10)
  summarise(range = max(LngtClass)-min(LngtClass),
            interval= range/20)

```



# Create cpue.length.year & cpue.year
```{r }

cpue.length.year <- cpue.length.subarea.yearqua %>%
  group_by(Region, Species,YearQua,Length) %>%
  summarize(CPUE_Length_Year=sum(CPUE_Length_Subarea_Yearqua)) 

# Sum of all CPUE per species (sum all length) per YearQua
cpue.year <- cpue.length.year %>%
  group_by(Region, YearQua, Species) %>%
  summarize(CPUE_Year = sum(CPUE_Length_Year)) 

#--------------------------------------------
# Compute Prop_CPUE_Length_Year

# 1 Add CPUE_Year to tibble cpue.length.year
cpue.length.year<-cpue.length.year %>%
  left_join(cpue.year,by=c("Region","YearQua","Species"))

# 2 Compute Prop_CPUE_Length_Year in cpue.length.year
cpue.length.year <- cpue.length.year %>% 
  mutate(Prop_CPUE_Length_Year = CPUE_Length_Year / CPUE_Year)

#----------------------------------------
# Create log_CPUE_Year in cpue.year
cpue.year <- cpue.year %>% 
  mutate(log_CPUE_Year = log(CPUE_Year))

#---------------------------------------
# Create scaleed log_CPUE_Year in cpue.length.year

# 1 scale function
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

# 2 Scale
cpue.length.year <- cpue.length.year %>% 
  group_by(Region,Species,Length) %>%
  mutate(CPUE_Length_Year_scale_log=
           scale_this(log(CPUE_Length_Year)))

```


#---------Compute spatial indices---------

# Compute home range and incorporate to cpue.year
```{r}

home.range.year <- cpue.subarea.yearqua %>%
  group_by(Region, Species, YearQua) %>%
  # use n_distinct(SubArea) to count the number of SubAreas
  summarise(Number_Subarea_All_Length=n_distinct(SubArea))

# incorporate to cpue.year
cpue.year <- full_join(cpue.year,home.range.year ,
                       by = c("Region", "Species", "YearQua"))

```

# Compute Num_SubArea and add to cpue.length.year

```{r}

# Compute Num_SubArea_Length, add to cpue.length.year
num.subarea.length <- cpue.length.subarea.yearqua %>%
  group_by(Region, Species, YearQua, Length) %>%
  summarise(Num_SubArea_Length = n_distinct(SubArea)) 

cpue.length.year <- 
  left_join(cpue.length.year, num.subarea.length, 
            by = c("Region","Species", "YearQua","Length"))


# add Number_SubArea_All_Length from home.range.year to cpue.length.year
cpue.length.year <- 
  left_join(cpue.length.year, home.range.year, 
            by = c("Region", "Species", "YearQua")) %>% 
  mutate_at("Length", as.factor)
 
```

# Compute Mean_Prop_SubArea and add to cpue.year
## @202312 Remove if possible
```{r}
# # Compute Mean_Prop_Subarea
# cpue.length.year.mean <-
#   cpue.length.year %>% 
#   group_by(Region,Species,YearQua) %>% 
#   summarise(Mean_Prop_SubArea = mean(Prop_SubArea_Length),
#             new = list(mean_se(Prop_SubArea_Length))) %>%
#   unnest(new)
# 
# 
# cpue.length.year.mean <-
#   cpue.length.year.mean %>% 
#   select(-y) %>% 
#   rename(Min_Prop_SubArea = ymin,
#          Max_Prop_SubArea = ymax)
#   
#   
# cpue.year <- 
#   left_join(cpue.year, cpue.length.year.mean, 
#             by = c("Region","Species", "YearQua"))

```


# Compute standardized subarea: ratio between number of occupied subareas of a size group of a year over maximum number of occupied subareas of this size group over time
```{r}

# 1 extract maximum range of size group over time then add to cpue.length.year

max.subarea.length <- num.subarea.length %>% 
  group_by(Region, Species, Length) %>% 
  summarise(Max_SubArea_Length = max (Num_SubArea_Length)) %>% 
  mutate_at("Length", as.factor)

cpue.length.year <- 
  left_join(cpue.length.year, max.subarea.length, 
            by = c("Region","Species", "Length"))

  
# 2 Compute standardized subarea length 
cpue.length.year <- cpue.length.year %>% 
  group_by(Region, Species, YearQua, Length) %>% 
  mutate(Stan_SubArea_Length = 
           Num_SubArea_Length / Max_SubArea_Length)


# 3 Compute mean standardized subarea and add to cpue.year
Stan_Subarea <- cpue.length.year %>% 
  group_by(Region, Species, YearQua) %>% 
  summarise(Mean_Stan_SubArea = mean(Stan_SubArea_Length))

cpue.year <- 
  left_join(cpue.year, Stan_Subarea, 
            by = c("Region","Species","YearQua"))

```

# Compute area-based SO for each paired size group 
```{r }

out <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # Subarea of length group x
  cpue.x <- cpue.length.subarea.yearqua %>%
  group_by(Region,Species,YearQua) %>%
  filter(Length==x & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # Subarea of length group y
  cpue.y <- cpue.length.subarea.yearqua %>%
  group_by(Region,Species,YearQua) %>%
  filter(Length==y & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # intersect 
  intersect <- 
  dplyr::intersect(cpue.x, cpue.y) %>%
  group_by (Region, Species, YearQua) %>%
  summarise(Number_intersect=n_distinct(SubArea),
            .groups = "drop")
  
  # union 
  union <- 
  dplyr::union(cpue.x, cpue.y) %>%
  group_by (Region, Species,YearQua) %>%
  summarise(Number_union=n_distinct(SubArea),
            .groups = "drop")

  # overlap
  overlap <- 
    full_join(intersect,union,
              by=c("Region","Species", "YearQua")) %>%
    replace_na(list(Number_intersect = 0)) %>%
    mutate(Area_overlap = Number_intersect / Number_union) 

  # Add x and y column (pair length)
  overlap <- overlap %>% add_column(x, y)
  
  # store in List
  out[[i]] <- overlap
  
}

out.all<-bind_rows(out,.id = "id") # id is combination of pairs

out.all.overlap <-out.all

# Calculate average area overlap among all combinations
average_out<-out.all %>%
  group_by(Region, Species,YearQua) %>%
  summarize(Mean_intersect = mean(Number_intersect),
            Mean_union = mean(Number_union),
            Paired_habitat_overlap = mean(Area_overlap, na.rm = T),
            # use mean_se() to create mean, min, and max area_overlap
            new = list(mean_se(Area_overlap)),
            .groups = "drop") %>%
  unnest(new) 

# incorporate average.out with cpue.yearqua
average_out_arranged <- average_out %>% 
  # remove y from new as is same as Mean_Area_Overlap
  select(-y) %>%  
  rename(Min_Paired_habitat_overlap = ymin,
         Max_Paired_habitat_overlap = ymax)
  
  cpue.year <- full_join(cpue.year,average_out_arranged, 
                       by = c("Region", "Species","YearQua"))

```



# Compute abundance-based SO for each paired size group 
```{r }


out_deno <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # Subarea of length group x
  cpue.x <- cpue.length.subarea.yearqua %>%
  group_by(Species,YearQua) %>%
  filter(Length==x & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # Subarea of length group y
  cpue.y <- cpue.length.subarea.yearqua %>%
  group_by(Species,YearQua) %>%
  filter(Length==y & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # intersect
  intersect <- 
  dplyr::intersect(cpue.x, cpue.y) %>%
  group_by (Region, Species, YearQua) %>%
  summarise(Number_intersect=n_distinct(SubArea),
             .groups = "drop")
  
  # denominator_x
  deno_x <- cpue.x %>% 
  group_by (Region, Species,YearQua) %>%
  summarise(Number_x = n_distinct(SubArea),
             .groups = "drop")

  # demoninator_y
  deno_y <- cpue.y %>% 
    group_by (Region, Species, YearQua) %>% 
    summarise(Number_y = n_distinct(SubArea),
               .groups = "drop")
  
  # join deno_x and deno_y
  deno <- full_join(deno_x, deno_y,
                    by = c("Region","Species", "YearQua"))
  
  # overlap_size_deno
  overlap_size_deno <- 
    full_join(intersect, deno,  
              by=c("Region","Species", "YearQua")) %>%
    replace_na(list(Number_intersect = 0)) %>%
    mutate(Area_overlap_deno_x = Number_intersect / Number_x,
           Area_overlap_deno_y = Number_intersect / Number_y) 

  # Add x and y column (pair length)
  overlap_size_deno <- overlap_size_deno %>% add_column(x, y)
  
  # store in List
  out_deno[[i]] <- overlap_size_deno
  
}

# bind lists by rows
out_deno_all<-bind_rows(out_deno,.id = "id") # id is combination of pairs

# create mean of Area_overlap_deno_x and Area_overlap_deno_y
out_deno_all <- out_deno_all %>% 
  mutate(Mean_Area_overlap_deno_xy = 
              1/2*(Area_overlap_deno_x + Area_overlap_deno_y))


# Calculate average area overlap among 190 combinations
average_out_deno_out <- out_deno_all %>%
  group_by(Region, Species,YearQua) %>%
  # use mean_se() to create mean, min, and max area_overlap
  summarize(Paired_habitat_overlap_deno = 
              mean(Mean_Area_overlap_deno_xy, na.rm = T),
            new = list(mean_se(Mean_Area_overlap_deno_xy)),
             .groups = "drop") %>%
  unnest(new) 


# incorporate average_out_deno_out with cpue.yearqua
average_out_deno_out <- average_out_deno_out %>% 
  # remove y from new as is same as Mean_Area_Overlap_deno
  select(-y) %>%  
  rename(Min_Paired_habitat_overlap_deno = ymin,
         Max_Paired_habitat_overlap_deno = ymax)
  
  
cpue.year <- full_join(cpue.year,average_out_deno_out, 
                       by = c("Region", "Species","YearQua"))

```

# Compute center of abundance (centroid in latitude and longitude) of each size group at each year 

```{r}

# Add lon, lat
cpue.length.subarea.yearqua.geo <- 
  cpue.length.subarea.yearqua %>% 
  mutate(lon = ices.rect(SubArea)$lon,
         lat = ices.rect(SubArea)$lat)

# calculate CPUE-weighted mean lon and lat for each length
cpue.length.subarea.yearqua.geo.mean <-
  cpue.length.subarea.yearqua.geo %>% 
  group_by(Region, Species, YearQua,Length) %>% 
  summarise(
    Centroid_lon = sum(CPUE_Length_Subarea_Yearqua * lon)/
      sum(CPUE_Length_Subarea_Yearqua),
    Centroid_lat = sum(CPUE_Length_Subarea_Yearqua * lat)/
      sum(CPUE_Length_Subarea_Yearqua)) %>%
  ungroup() %>% 
  mutate_at('Length',as.factor)
  

# Add to cpue.length.yearqua
cpue.length.year <- 
  full_join(cpue.length.year,
            cpue.length.subarea.yearqua.geo.mean,
            by=c("Region", "Species", "YearQua","Length"))  


```


# Compute distance between center of abundance for each size group pair

```{r}

# All 190 pair combinations

# combn(0:19,2)

out_centroid <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # subset of length group x
  lon.lat.x <- cpue.length.year %>%
    group_by(Region,Species,YearQua) %>%
    filter(Length == x) %>% 
    dplyr::select(Region, Species, Length,YearQua, 
                  Centroid_lon, Centroid_lat)
  
  # subset of length group y
  lon.lat.y <- cpue.length.year %>%
    group_by(Region,Species,YearQua) %>%
    filter(Length == y) %>% 
    dplyr::select(Region, Species, Length,YearQua, 
                  Centroid_lon, Centroid_lat)
  
  # join x and y
  lon.lat.xy <- 
    full_join(lon.lat.x, lon.lat.y,
              by=c("Region","Species", 
                   "YearQua"))

  # Absoluate distance between centroids
  lon.lat.xy <- lon.lat.xy %>% 
    mutate(Distance_lon = abs(Centroid_lon.x - Centroid_lon.y),
           Distance_lat = abs(Centroid_lat.x - Centroid_lat.y)) 

  # Add x and y column (pair length)
  lon.lat.xy <- lon.lat.xy %>% add_column(x, y)
  
  # store in List
  out_centroid[[i]] <- lon.lat.xy
  
}


out_centroid_all<-bind_rows(out_centroid,.id = "id") # id is combination of pairs


# Calculate average area overlap among 45 combinations
average_out_centroid <- out_centroid_all %>%
  group_by (Region, Species,YearQua) %>%
  summarize(new = list(mean_se(Distance_lon)),
            new1 = list(mean_se(Distance_lat))) %>%
  unnest(new) %>% 
  rename(Mean_paired_lon_distance = y,# delete this later
         Min_paired_lon_distance = ymin,
         Max_paired_lon_distance = ymax) %>% 
  unnest(new1) %>% 
    rename(Mean_paired_lat_distance = y,# delete this later
         Min_paired_lat_distance = ymin,
         Max_paired_lat_distance = ymax) 
    

# incorporate average_out_centroid with cpue.year
  
cpue.year <- full_join(cpue.year,average_out_centroid, 
                       by = c("Region", "Species","YearQua"))


```

# Combine spatial indice data together into tibble cpue.pair
```{r}

# retain useful variables for 3 tibbles
out.all.overlap <- out.all.overlap %>% 
  select(- Number_intersect, - Number_union)
  
out_deno_all <- out_deno_all %>% 
  select(- Area_overlap_deno_x, - Area_overlap_deno_y,
         - Number_intersect, - Number_x, - Number_y,
         )
  
out_centroid_all <- out_centroid_all %>% 
  select(id,Region,Species,YearQua,Distance_lon,
         Distance_lat,x, y)

# bind 3 tibbles
out_temp <- left_join(out.all.overlap,out_deno_all,
          by = c ("id","Region","Species","YearQua",
                  "x","y"))

cpue.pair <- left_join(out_temp, out_centroid_all,
          by = c ("id","Region","Species","YearQua",
                  "x","y"))

# House cleaning
cpue.pair <- cpue.pair %>% 
  rename(Pair_id = id) 

```


# House keeping (separate year and quarter)
```{r}

# Add Year, Quarter to all tibbles
cpue.lngt.yearqua <- cpue.lngt.yearqua %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.length.subarea.yearqua <- cpue.length.subarea.yearqua %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.length.year<- cpue.length.year %>% 
   separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.year <-cpue.year %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)
  
cpue.pair <- cpue.pair %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)
  
``` 

# import fishing mortality & stock biomass data
```{r}

FishingM <-read.csv("~/Dropbox/Academic/Ecoinformatics/a0_FishSpatial_MS/a_spatial_overlap_analysis/data/Fishing_Mortality.csv")

FishingM <- FishingM %>% 
  mutate_at("Species", as.factor) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("TSB_Tonnes", as.numeric)

# join fishing mortality and TSB data into three data tibbles
cpue.year <- left_join(cpue.year, FishingM, by = c("Year", "Species"))

cpue.length.year <- left_join(cpue.length.year, FishingM, by = c("Year", "Species"))

cpue.pair <- left_join(cpue.pair,FishingM, by = c("Year","Species"))

# housekeeping
cpue.year <- cpue.year %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

cpue.length.year <- cpue.length.year %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

cpue.pair <- cpue.pair %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

```

# Import self-compiled temperature data

```{r}

# Read self compiled bottomT data 1977-2019
Temp_NS <-read.csv("~/Dropbox/Academic/Ecoinformatics/a0_FishSpatial_MS/a_spatial_overlap_analysis/data/bottomT_NS_1977_2019.csv")


# join temperature data into three data tibbles
cpue.length.year <- left_join(cpue.length.year, Temp_NS,
          by=c("Year","Quarter"))

cpue.year <- left_join(cpue.year, Temp_NS,
          by=c("Year","Quarter"))

cpue.pair <- left_join(cpue.pair,Temp_NS,
                                  by = c("Year","Quarter"))

```

# scale year and drivers

```{r}

scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

# Create tibble Year.scale with scaled year 
Year.scale <-  tibble(Year = seq(1977,2019,1)) %>% 
  mutate(Year_scale_centered=scale_this(Year))

#1 scale variables in cpue.year
cpue.year <- cpue.year %>% 
  mutate(MeanBT_scale = scale_this(MeanBT)) %>% 
  mutate(TSB_Tonnes_scale = scale_this(TSB_Tonnes))

cpue.year <- left_join(cpue.year,Year.scale,
                       by = "Year")

#2 scale variables in cpue.pair
cpue.pair <- cpue.pair %>% 
  mutate(MeanBT_scale = scale_this(MeanBT)) %>% 
  mutate(TSB_Tonnes_scale = scale_this(TSB_Tonnes))

cpue.pair <- left_join(cpue.pair,Year.scale,
                       by = "Year")

#3 scale variables in cpue.length.year
cpue.length.year <- left_join(cpue.length.year,Year.scale,
                              by = "Year")

```


# Save all tibbles as RData 

```{r}

save(cpue.lngt.subarea.yearqua, cpue.lngt.yearqua, cpue.length.subarea.yearqua, cpue.length.year, cpue.year, cpue.pair,
     file = "~/Dropbox/Academic/Ecoinformatics/a0_FishSpatial_MS/a_spatial_overlap_analysis/output/spatial_overlap.RData")

```

#---------results: spatial overlap over time Fig 1

# linear regression for spatial overlap 

```{r message = FALSE}

# function for union overlapped area
Area_overlap_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Area_overlap) ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  R2_m <- r.squaredGLMM(m)[1,1]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap",
         F_value,p_value, R2_c, R2_m,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_o <- Area_overlap_function("Atlantic cod",cpue.pair)
haddock_o <- Area_overlap_function("Haddock",cpue.pair)
whiting_o <- Area_overlap_function("Whiting",cpue.pair)
model.overlap.output <- rbind(cod_o, haddock_o, whiting_o)



# function for partial overlapped area 
Area_overlap_deno_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Mean_Area_overlap_deno_xy) ~
              Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  R2_m <- r.squaredGLMM(m)[1,1]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap_deno",
         F_value,p_value, R2_c,R2_m,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_d <- Area_overlap_deno_function("Atlantic cod",cpue.pair)
haddock_d <- Area_overlap_deno_function("Haddock",cpue.pair)
whiting_d <- Area_overlap_deno_function("Whiting",cpue.pair)
model.overlap.output.deno <- rbind(cod_d, haddock_d, whiting_d)

# output table combine
model.overlap.output.all <- rbind(model.overlap.output,model.overlap.output.deno)

```


# Functions to extract model predictions

```{r}

# function predicting union overlapped area
mod_overlap <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Area_overlap
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

# function predicting partial overlapped area
mod_overlap_deno <- function(species){
  d1 <- cpue.pair %>% filter(Species == species) 
  x <- cpue.pair %>% filter(Species == species) %>% pull(Year)
  y <- cpue.pair %>% filter(Species == species) %>% pull(Mean_Area_overlap_deno_xy)
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)}

```


# Run functions to extract model predictions

```{r}

# Run both functions and combine results in < mod.overlap.all >

mod.overlap <- rbind(mod_overlap("Atlantic cod"),
      mod_overlap("Haddock"),
      mod_overlap("Whiting"))

mod.overlap <- tibble(Response = "Area_overlap", mod.overlap)


mod.overlap.deno <- rbind(mod_overlap_deno("Atlantic cod"),
                          mod_overlap_deno("Haddock"),
                          mod_overlap_deno("Whiting"))

mod.overlap.deno <- tibble(Response = "Area_overlap_deno",
                            mod.overlap.deno)

mod.overlap.all <- rbind(mod.overlap,mod.overlap.deno)

```

# Fig.1a-c spatial overlap over time
```{r message =FALSE}

# Plot Area_overlap
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Area_overlap * 100)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.overlap,
            aes(x = x,
                y = exp(Fitted)/(1+exp(Fitted))*100),
            color = "black", size = 1.5)+
  facet_wrap(vars(Species))+
  scale_color_viridis_d(alpha = .3) +
  xlab("Year") +
  ylab("Pairwise range overlap") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        panel.spacing = unit(0.9, "lines"),
        strip.text.x = element_text(size = 11))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))
        
# Plot Area_overlap_deno
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), 
           y = Mean_Area_overlap_deno_xy * 100)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.overlap.deno,
            aes(x = x,
                y = exp(Fitted)/(1+exp(Fitted))*100),
            color = "black", size = 1.5)+
  facet_wrap(vars(Species))+
  scale_color_viridis_d(alpha = .3) +
  xlab("Year") +
  ylab("Pairwise range overlap deno") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))

```







#----------Fig 2.1 Range of individual size------

# lmer logit (Year|Length)
```{r}

Range_size_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Stan_SubArea_Length) ~ Year_scale_centered +
              (Year_scale_centered|Length),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_s <- Range_size_function("Atlantic cod",cpue.length.year)
haddock_s <- Range_size_function("Haddock",cpue.length.year)
whiting_s <- Range_size_function("Whiting",cpue.length.year)
model.RangeSize.output <- rbind(cod_s, haddock_s, whiting_s)

Length.20
```

# Save model output
```{r}
# 20 length
write.csv(model.RangeSize.output ,
          file ="a_RData_3Species/20Length_model_RangeSize_output.csv")
```

# Model diagnostics
Code to diagnose model for individual species  

```{r eval = FALSE}

data.cod <- cpue.length.year %>% 
  filter(Species == "Atlantic cod")

data.haddock <- cpue.length.year %>% 
  filter(Species == "Haddock") 

data.whiting <- cpue.length.year %>% 
  filter(Species == "Whiting") 

# glmer
m1 <- glmer(Stan_SubArea_Length ~ Year_scale_centered +
              (1|Length), family = binomial, data.cod)
summary(m1)
r.squaredGLMM(m1)
plot(m1)
simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 


# lmer logit
m1 <- lmer(logit(Stan_SubArea_Length) ~ 
             Year_scale_centered+
            (Year_scale_centered|Length),
            data.haddock)
summary(m1)
anova(m1)
coef(m1)$Length %>%
  summarise(mean = mean(Year_scale_centered))
plot(m1)
r.squaredGLMM(m1) 
simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 
```


# Model prediction for fixed effect
```{r}

# prediction for all species
model_prediction_RS <- function(species){
  dd <- cpue.length.year %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Stan_SubArea_Length
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble.model <- tibble(Species = species, model.fit)
  rename(tibble.model, xvar = x)
  }

prediction.cod.RS <- model_prediction_RS("Atlantic cod")
prediction.haddock.RS <- model_prediction_RS("Haddock")
prediction.whiting.RS <- model_prediction_RS("Whiting")

prediction.3species.RS <- 
rbind(prediction.cod.RS,
      prediction.haddock.RS,
      prediction.whiting.RS)

```




# Fig. Range size
output: PDF 3 x 8
```{r message = FALSE}

# Order size groups
cpue.length.year <- cpue.length.year %>% 
  mutate(
    Length = factor
    (Length,levels=c("0","1","2","3","4","5","6",
                     "7","8","9","10","11","12","13",
                     "14","15","16","17","18","19")))

# Plot
ggplot(data = cpue.length.year,
       aes(x = as.numeric(YearQua), 
           y = Stan_SubArea_Length * 100)) +
  facet_wrap(~Species)+
  geom_line(aes(color = Length))+
  # Solid line for Atlantic cod and haddock
  geom_line(data = prediction.3species.RS%>% 
              filter (Species %in% c("Atlantic cod", "Haddock")),
            aes(x = xvar,
                y = (exp(Fitted)/(1+exp(Fitted)))*100),
            color = "black", size = 1.5)+
  scale_color_viridis_d(alpha = .5)+
  xlab("Year") +
  ylab("Standardized distriubtion range") +
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  theme(legend.position = "none")

```


#---------------Fig 2.2 2.3 Paired disance --------

# lmer logit (Year|Length)
```{r}

Lon_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(Distance_lon ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Distance_lon",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_lon <- Lon_function("Atlantic cod",cpue.pair)
haddock_lon <- Lon_function("Haddock",cpue.pair)
whiting_lon <- Lon_function("Whiting",cpue.pair)
model.lon.output <- rbind(cod_lon, haddock_lon, whiting_lon)



Lat_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(Distance_lat ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Distance_lat",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_lat <- Lat_function("Atlantic cod",cpue.pair)
haddock_lat <- Lat_function("Haddock",cpue.pair)
whiting_lat <- Lat_function("Whiting",cpue.pair)
model.lat.output <- rbind(cod_lat, haddock_lat, whiting_lat)

# Combine lon+lat output
model.dist.output <- rbind(model.lon.output,
                           model.lat.output)

```

# Save model output
```{r}
write.csv(model.dist.output,
          file ="a_RData_3Species/20Length_model_Distance_output.csv")

```


# Model diagnostics
Code to diagnose model for individual species  

```{r eval = FALSE}
## Response: Area_overlap, Mean_Area_overlap_deno_xy
cpue.pair.cod <- cpue.pair %>% 
  filter(Species == "Atlantic cod") 

cpue.pair.haddock <- cpue.pair %>% 
  filter(Species == "Haddock") 

cpue.pair.whiting <- cpue.pair %>% 
  filter(Species == "Whiting") 

m1 <- lmer((Distance_lon) ~ 
             Year_scale_centered+
            (Year_scale_centered|Pair_id),
            family = poisson,
            cpue.pair.haddock)
summary(m1)
coef(m1)$Pair_id %>%
  summarise(mean = mean(Year_scale_centered))
plot(m1)
r.squaredGLMM(m1) 

simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 


```



# Model prediction for fixed effect
```{r}

# Model prediction lon

mod_lon <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Distance_lon
  m <- lm(y~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

mod.lon.all <- rbind(mod_lon("Atlantic cod"),
                     mod_lon("Haddock"),
                     mod_lon("Whiting"))


# Model prediction lat

mod_lat <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Distance_lat
  m <- lm(y~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

mod.lat.all <- rbind(mod_lat("Atlantic cod"),
                     mod_lat("Haddock"),
                     mod_lat("Whiting"))

```


# Fig. Paired_lon/lat
output: PDF 3 x 8
```{r message =FALSE}

# Check max lon and lat
cpue.pair %>%
  summarise(lon_max = max(Distance_lon, na.rm = T),
            lat_max = max(Distance_lat, na.rm = T))

# Lon
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Distance_lon )) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.lon.all %>% 
              filter(Species %in% c("Haddock","Whiting")),
            aes(x = x,
                y = Fitted), size = 1.5)+
  facet_wrap(vars(Species), "free_y")+
  xlab("Year") +
  ylab("Distance_lon") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 9, by = 3),
                     limits = c(0,12))

# Lat
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Distance_lat)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.lat.all,
            aes(x = x,
                y = Fitted), size = 1.5)+
  facet_wrap(vars(Species), "free_y")+
  xlab("Year") +
  ylab("Distance_lat") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 9, by = 3),
                     limits = c(0,12))



```



#-----which size is the most important
#1 each size with other sizes
```{r}

cpue.pair.other <- cpue.pair %>% 
  group_by(Region, Species, Year,x) %>% 
  summarise(mean_overlap_with_other= mean(Area_overlap)) %>% 
  mutate_at('x',as.factor)

cpue.pair.other.cod <- 
  cpue.pair.other %>% filter(Species == "Atlantic cod") 

plot_fun <- function(species){
  d1 <- cpue.pair.other %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = mean_overlap_with_other, colour = x))+
  geom_point() +
  geom_line(aes(colour = x))+
  geom_smooth(method='loess', formula= y~x)+
  geom_smooth(method='loess', formula= y~x, color = "black")}




```

#2 fig2 plot mature-mature, juv-juv, mature-juv
group at maturation: 7, 8, 7 for cod, haddock, whiting, respectively.
```{r}

#1 replace x with mature or juv
juv_adu_fun <- function(species, group.at.maturity) {
  cpue.pair %>% filter(Species == species) %>% 
  mutate(x_stage = replace(x, x < group.at.maturity,"juv")) %>% 
  mutate(x_stage = replace(x_stage, x >= group.at.maturity, "adu")) %>% 
  mutate(y_stage = replace(y, y < group.at.maturity,"juv")) %>% 
  mutate(y_stage = replace(y_stage, y >= group.at.maturity, "adu"))
    }

d1 <- juv_adu_fun("Atlantic cod", 7)
d2 <- juv_adu_fun("Haddock", 8)  
d3 <- juv_adu_fun("Whiting", 7)

dd.juv.adu <- rbind(d1,d2,d3)


#2 create three caterogies
dd.juv.adu.1 <- dd.juv.adu %>% 
  mutate(stage ="a") %>% 
  mutate(stage = replace(stage, x_stage =="juv" & y_stage == "juv", "juv_juv")) %>% 
   mutate(stage = replace(stage, x_stage =="juv" & y_stage == "adu", "juv_adu")) %>% 
   mutate(stage = replace(stage, x_stage =="adu" & y_stage == "adu", "adu_adu")) %>% 
  filter(stage != "a")
  
# aggregate based on three caterogies  
cpue.pair.stage <- dd.juv.adu.1 %>% 
  ungroup() %>% 
  group_by(Region, Species, Year, stage) %>% 
  summarise(mean_overlap = mean(Area_overlap))


plot_fun <- function(species){
  d1 <- cpue.pair.stage %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = mean_overlap, colour = stage))+
  geom_point() +
  geom_line(aes(colour = stage))+
  geom_smooth(method='lm', formula= y~x)+ theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))
    }


plot_fun("Atlantic cod")
plot_fun("Haddock")
plot_fun("Whiting")

```

#3 distribtuion area change: stage based
```{r}
# replace with stage

cpue.length.year

juv_adu_fun <- function(species, group.at.maturity) {
  cpue.length.year %>% filter(Species == species) %>% 
    mutate_at("Length", as.numeric) %>% 
  mutate(Stage = replace(Length, Length < group.at.maturity,"juv")) %>% 
  mutate(Stage = replace(Stage, Length >= group.at.maturity, "adu")) 
    }

d1 <- juv_adu_fun("Atlantic cod", 7)
d2 <- juv_adu_fun("Haddock", 8)  
d3 <- juv_adu_fun("Whiting", 7)

cpue.length.year.stage <- rbind(d1,d2,d3)


# plot
plot_fun <- function(species){
  d1 <- cpue.length.year.stage %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = Num_SubArea_Length, colour = Stage))+
  geom_point() +
  #geom_line(aes(colour = ))+
  geom_smooth(method='lm', formula= y~x, se = F)+
    scale_color_viridis_d(alpha = .5)+
    theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
    ylab("absolute number of occupied rectangles")+
    ggtitle(species)}
  

p1 <- plot_fun("Atlantic cod")
p2 <- plot_fun("Haddock")
p3 <- plot_fun("Whiting")


```


#4 distribution area change: size based

```{r}
cpue.length.year

plot_fun <- function(species){
  d1 <- cpue.length.year %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = Num_SubArea_Length, colour = Length))+
  geom_point() +
  #geom_line(aes(colour = Length))+
  geom_smooth(method='loess', formula= y~x, se = F)+
    scale_color_viridis_d(alpha = .5)}

plot_fun("Atlantic cod")
plot_fun("Haddock")
plot_fun("Whiting")

```


# 4 fig2 corrplot
##1  Exract pairwise slope
```{r eval=F}

#-------- Extract slope from lm (overlap ~ time)

## 1 nest data 
n_overlap <- out.all %>% 
  #ungroup(YearQua) %>% 
  mutate_at('YearQua', as.numeric) %>% 
  group_by(Region,Species, x, y) %>% 
  nest() 

## 2 Apply regression
fun_overlap <-function(df) lm (Area_overlap ~ YearQua, data = df)

m_overlap <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap))


## 3 Extract slope and confidence interval of slope
slope_fun <- function(mod) coefficients(mod)[[2]]
#ci_lower_fun <- function(mod) confint(mod)[2,1]
#ci_upper_fun <- function(mod) confint(mod)[2,2]

m_overlap_summary <- m_overlap %>% 
  transmute(., slope = map_dbl(model, slope_fun)
            #,lower_ci = map_dbl(model, ci_lower_fun),
            #upper_ci = map_dbl(model, ci_upper_fun)
            )

#----------Check model fit

m_overlap_all <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap),
         tidied = purrr::map(model, tidy),
         glanced = purrr::map(model, glance),
         augmented = purrr::map(model, augment))

m_overlap_all %>%
  unnest(tidied)

m_overlap_all %>%
  unnest(augmented)

# p-value, r-square, adjusted r-square
overlap_statistics_table <-
m_overlap_all %>%
  unnest(glanced) %>% 
  select(Region, Species, x,y,r.squared,
         adj.r.squared, p.value)

```

##2 Plot
```{r}

#--------- Prepare dataframe
# select slope column & filter size class
m_overlap_summary <- 
  m_overlap_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope) 
#%>% filter(x > 0 & y >1)

corr.data  <- m_overlap_summary %>% 
  ungroup(Region) %>% 
  select(-Region)

## transform data from long to wide
corr.data  <- # long to wide form
  pivot_wider(corr.data, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
corr.data <- corr.data %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# color limits
m_overlap_summary %>% 
  ungroup() %>% 
  summarise(min = min(slope),
            max = max(slope))

# Data by species
dd.cod <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd.cod<- dd.cod[,-c(1,2)]  
dd.cod <- as.matrix(dd.cod)
#rownames(dd.cod) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.cod

dd.haddock <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd.haddock<- dd.haddock[,-c(1,2)]  
dd.haddock <- as.matrix(dd.haddock)
#rownames(dd.haddock) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.haddock

dd.whiting <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd.whiting  <- dd.whiting [,-c(1,2)]  
dd.whiting<- as.matrix(dd.whiting )
#rownames(dd.whiting ) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.whiting 

# Plot
par(mfrow = c(1,3))
p1 <- corrplot(dd.cod,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Atlantic cod"),
         mar=c(0,0,2,0)) 

p2 <- corrplot(dd.haddock,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Haddock"),
         mar=c(0,0,2,0)) 


p3 <- corrplot(dd.whiting ,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(30), 
         title = paste0("Whiting"),
         mar=c(0,0,2,0)) 
 

```

##3 @0220315 Plot with autocorrelation
```{r}

# select slope column & filter size class
m_overlap_summary <- 
  m_overlap_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope) 

# add autocorrelation
auto_dd <- tibble(Region = "North Sea", 
       Species = rep(c("Atlantic cod", "Haddock", "Whiting"),20),
       x = rep(c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19),
               each = 3),
       y = rep(c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19),
               each = 3),
       slope = 0)

summary.auto <- bind_rows(m_overlap_summary, auto_dd)

#--------- Prepare dataframe
corr.data  <- summary.auto %>% 
  ungroup(Region) %>% 
  select(-Region)

## transform data from long to wide
corr.data  <- # long to wide form
  pivot_wider(corr.data, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
corr.data <- corr.data %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# color limits
m_overlap_summary %>% 
  ungroup() %>% 
  summarise(min = min(slope),
            max = max(slope))

# Data by species
dd.cod <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd.cod<- dd.cod[,-c(1,2)]  
dd.cod <- as.matrix(dd.cod)
rownames(dd.cod) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.cod


dd.haddock <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd.haddock<- dd.haddock[,-c(1,2)]  
dd.haddock <- as.matrix(dd.haddock)
rownames(dd.haddock) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.haddock

dd.whiting <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd.whiting  <- dd.whiting [,-c(1,2)]  
dd.whiting<- as.matrix(dd.whiting )
rownames(dd.whiting ) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.whiting 

# Plot
par(mfrow = c(1,3))
p1 <- corrplot(dd.cod,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Atlantic cod"),
         mar=c(0,0,2,0)) 

p2 <- corrplot(dd.haddock,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Haddock"),
         mar=c(0,0,2,0)) 


p3 <- corrplot(dd.whiting ,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(30), 
         title = paste0("Whiting"),
         mar=c(0,0,2,0)) 
 
```


##4 Plot cod based on its scale
```{r}
par(mfrow = c(1,1))

p1 <- corrplot(dd.cod,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0), # for overlap
         col = col2(50), 
         title = paste0("Atlantic cod"),
         mar=c(0,0,2,0)) 

```



#---------------Fig 2.4 Relationship-----------


# Regression_Diff_AR: improved overlap~ stan_area+ Dis 
use AR1
No interactive effect, so no interactive term
```{r}

# 1 Calculate AR for overlap & overlap_deno
cpue.year.ar <- cpue.year %>% 
  group_by(Species, Region) %>% 
  # Calculate overlap AR
  mutate(ar1_over = lag(Paired_habitat_overlap),
         ar2_over = lag(ar1_over),
         ar3_over = lag(ar2_over),
         ar4_over = lag(ar3_over)) %>% 
  # Calculate overlap first difference as model response variable
  mutate(diff_over = Paired_habitat_overlap - ar1_over) %>%
  # Overlap_deno AR
  mutate(ar1_deno = lag(Paired_habitat_overlap_deno),
         ar2_deno = lag(ar1_deno),
         ar3_deno = lag(ar2_deno),
         ar4_deno = lag(ar3_deno)) %>% 
  # Overlap_deno first difference as model response variable
  mutate(diff_deno = 
           Paired_habitat_overlap_deno - ar1_deno)


# 2 Standardize (scale_this)
cpue.year.ar <- cpue.year.ar %>% 
  group_by(Species, Region) %>% 
  mutate(
    s_SubArea = scale_this(Mean_Stan_SubArea),
    s_LonDist = scale_this(Mean_paired_lon_distance),
    s_LatDist = scale_this(Mean_paired_lat_distance))

# 3 Subset needed variables
cpue.year.ar <- cpue.year.ar %>% 
  select(Species, diff_over,ar1_over,ar2_over,ar3_over,
         ar4_over, diff_deno,ar1_deno,ar2_deno,
         ar3_deno,ar4_deno,s_SubArea,s_LonDist,
         s_LatDist)

# 4 Subset to species
dd.cod <- cpue.year.ar %>% 
  filter(Species == "Atlantic cod")

dd.haddock <- cpue.year.ar %>% 
  filter(Species == "Haddock")

dd.whiting <- cpue.year.ar %>% 
  filter(Species =="Whiting")


# 5 Check corr between Stan_range, lon_distance, lat_distance

cor(dd.cod[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.haddock[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.whiting[,c("s_SubArea","s_LonDist","s_LatDist")])


# 6 Function to model, statistics, and coef_table
## 1 Overlap
overlap_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Overlap
  m <- lm(diff_over ~ ar1_over + 
          s_SubArea + s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_over <- 
    tibble(Species = species,
           Response = "Overlap", 
           Explanatory = 
             c("SubArea", "LonDist","LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m),anova(m),summary(m),dd_over)
  
}


## 2 Deno
deno_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Deno
  m <- lm(diff_deno ~ ar1_over +  
            s_SubArea +s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_deno <- 
    tibble(Species = species,
           Response = "Overlap_deno",
           Explanatory = 
             c("SubArea", "LonDist", "LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m), anova(m),summary(m),dd_deno)
  
}


overlap_model("Atlantic cod")
overlap_model("Haddock")
overlap_model("Whiting")
deno_model("Atlantic cod")
deno_model("Haddock")
deno_model("Whiting")



cor.test(dd.haddock$s_SubArea,dd.haddock$s_LonDist)

```


# 20210812 Regression_logistic_AR: improved overlap~ stan_area+ Dis use AR1
vif of glm(family = binomial(link = "logit)) is higher than lm approach.
```{r}

# 1 Calculate AR for overlap & overlap_deno
cpue.year.ar <- cpue.year %>% 
  group_by(Species, Region) %>% 
  # Calculate overlap AR
  mutate(ar1_over = lag(Paired_habitat_overlap),
         ar2_over = lag(ar1_over),
         ar3_over = lag(ar2_over),
         ar4_over = lag(ar3_over)) %>% 
  # Calculate overlap first difference as model response variable
  mutate(diff_over = Paired_habitat_overlap - ar1_over) %>%
  # Overlap_deno AR
  mutate(ar1_deno = lag(Paired_habitat_overlap_deno),
         ar2_deno = lag(ar1_deno),
         ar3_deno = lag(ar2_deno),
         ar4_deno = lag(ar3_deno)) %>% 
  # Overlap_deno first difference as model response variable
  mutate(diff_deno = 
           Paired_habitat_overlap_deno - ar1_deno)


# 2 Standardize (scale_this)
cpue.year.ar <- cpue.year.ar %>% 
  group_by(Species, Region) %>% 
  mutate(
    s_SubArea = scale_this(Mean_Stan_SubArea),
    s_LonDist = scale_this(Mean_paired_lon_distance),
    s_LatDist = scale_this(Mean_paired_lat_distance))

# 3 Subset needed variables
cpue.year.ar <- cpue.year.ar %>% 
  select(Species,Year,Paired_habitat_overlap, 
         Paired_habitat_overlap_deno,
         diff_over,ar1_over,ar2_over,ar3_over,
         ar4_over, diff_deno,ar1_deno,ar2_deno,
         ar3_deno,ar4_deno,s_SubArea,s_LonDist,
         s_LatDist)

# 4 Subset to species
dd.cod <- cpue.year.ar %>% 
  filter(Species == "Atlantic cod")

dd.haddock <- cpue.year.ar %>% 
  filter(Species == "Haddock")

dd.whiting <- cpue.year.ar %>% 
  filter(Species =="Whiting")


# 5 Check corr between Stan_range, lon_distance, lat_distance

cor(dd.cod[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.haddock[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.whiting[,c("s_SubArea","s_LonDist","s_LatDist")])


# 6 Function to model, statistics, and coef_table
## 1 Overlap
overlap_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Overlap
  m <- lm(diff_over ~ ar1_over +  
            s_SubArea +s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_over <- 
    tibble(Species = species,
           Response = "Overlap", 
           Explanatory = 
             c("SubArea", "LonDist","LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m),anova(m),summary(m),dd_over)
  
}


## 2 Deno
deno_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Deno
  m <- lm(diff_deno ~ ar1_deno +  
            s_SubArea +s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_deno <- 
    tibble(Species = species,
           Response = "Overlap_deno",
           Explanatory = 
             c("SubArea", "LonDist", "LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m), anova(m),summary(m),dd_deno)
  
}


overlap_model("Atlantic cod")
overlap_model("Haddock")
overlap_model("Whiting")
deno_model("Atlantic cod")
deno_model("Haddock")
deno_model("Whiting")

# vif of glm approach is higher than lm approach.
# m<- lm(diff_over ~ ar1_over + 
#           s_SubArea + s_LonDist + s_LatDist, dd.cod)
# summary(m)
# vif(m)
# plot(m)
# 
# m2 <- glm(Paired_habitat_overlap ~ Year + ar1_over + 
#           s_SubArea + s_LonDist + s_LatDist,
#           family = binomial(link = "logit"), dd.cod)
# 
# vif(m2)
# plot(m2)
# summary(m2)
# anova(m2)

```



# Compile stat table and plot
output PDF 3 x 4
Alter the title name by species
```{r}

over.cod <- overlap_model("Atlantic cod")
over.had <- overlap_model("Haddock")
over.whi <- overlap_model("Whiting")
deno.cod <- deno_model("Atlantic cod")
deno.had <- deno_model("Haddock")
deno.whi <- deno_model("Whiting")


# Plot function
coef_plot <- function(species, dd.over, dd.deno){
  dd <- rbind(dd.over[[4]],dd.deno[[4]])
  pd <- position_dodge(width=0.8)
  dd$Explanatory <- factor(dd$Explanatory,
    levels = c('SubArea','LonDist','LatDist'),
    ordered = TRUE)
  ggplot(dd,aes(x = Explanatory, y = coef, group = Response))+
  geom_point(position = pd, aes(shape = Response),
             size = 2)+
    scale_shape_manual(values=c(0, 2))+
  geom_errorbar(aes(ymin = conf25, ymax= conf75),
                position = pd,
                width = 0.4,
                size = 0.7)+
    #facet_grid(. ~ "Atlantic cod")+
    #facet_grid(. ~ "Haddock")+
    facet_grid(. ~ "Whiting")+
    
  #scale_color_manual(values=c("coral","steelblue")) +
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"))+
    labs(y = "Model coefficient", x = "")+
    scale_x_discrete(labels = c('Range \n size',
              'Distance\n lon',
              'Distance\n Lat'))+
    scale_y_continuous(
      breaks = seq(-0.04, 0.12, 0.04),
      limits=c(-0.04, 0.12))+
    geom_hline(yintercept=0, linetype="dashed", color = "black")+
    theme(strip.text.x = element_text(size = 11))}

coef_plot("Atlantic cod", over.cod, deno.cod)
coef_plot("Haddock", over.had, deno.had)
coef_plot("Whiting", over.whi, deno.whi)

# Check R2 for plots
over.cod[[3]]$adj.r.squared
over.had[[3]]$adj.r.squared
over.whi[[3]]$adj.r.squared
deno.cod[[3]]$adj.r.squared
deno.had[[3]]$adj.r.squared
deno.whi[[3]]$adj.r.squared

# Check p-value
over.cod[[2]]
over.had[[2]]
over.whi[[2]]
deno.cod[[2]]
deno.had[[2]]
deno.whi[[2]]

```






#------------------Fig 3 Size-specific pattern
# Model range ~ time

```{r}

# 2021.11.26 Create logit_Stan_SubArea_Length
cpue.length.year <- cpue.length.year %>% 
  mutate(Logit_Stan_SubArea_Length = 
           logit(Stan_SubArea_Length))

# Use gather to create a column with all Y-variables
cpue.length.year.y.gather <- cpue.length.year %>% 
  #ungroup(YearQua) %>% 
  mutate_at('Length', as.character) %>%
  mutate_at('YearQua', as.numeric) %>% 
  mutate(CPUE_Length_Year_log = log(CPUE_Length_Year)) %>% 
  filter(Length %in% c(0,1,2,3,4,5,6,7,8,9,10,
                       11,12,13,14,15,16,17,18,19)) %>% 
  gather(key="Variables", value="value",
         CPUE_Length_Year_log,Prop_CPUE_Length_Year,
         Num_SubArea_Length, Prop_SubArea_Length,
         Centroid_lon, Centroid_lat,
         Stan_SubArea_Length,
         Logit_Stan_SubArea_Length) 

# Re-order Length
cpue.length.year.y.gather <- cpue.length.year.y.gather %>% 
  mutate(Length = factor(Length, levels = c("0","1","2","3","4","5","6",
                              "7","8","9","10","11","12","13","14",
                              "15","16","17","18","19")))


# Split by Variables
## Use split + imap can generate automatic plot titles
cpue.length.year.pl <- cpue.length.year.y.gather %>% 
  split(list(cpue.length.year.y.gather$Variables,
             cpue.length.year.y.gather$Region))


# Create plot function
plot.fun <- function(.x,.y){
  ggplot(data=.x, aes(x=YearQua,y=value))+
    geom_point(size = 0.5, colour = "grey")+
    facet_grid(Species~Length,scales= "free_y")+   
    scale_y_continuous(name = element_blank()) +
    geom_smooth(method='lm', formula= y~x, color = "black")+
    xlab("Year") + theme + ggtitle(.y)
  }

# plot with imap
purrr::imap(cpue.length.year.pl,plot.fun)


```


# Plot slope of CPUE & habitat~ time 

```{r}
theme <- 
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"),
    legend.position="none")


n.data <- cpue.length.year.y.gather %>% 
  group_by(Region, Species, Length, Variables) %>% 
  nest()


mod_fun <-function(df)lm(value ~ YearQua, data = df)

mod.data <- n.data %>% 
  mutate(model = purrr::map(data, mod_fun))

slope_fun <- function(mod) coefficients(mod)[[2]]
ci_lower_fun <- function(mod) confint(mod)[2,1]
ci_upper_fun <- function(mod) confint(mod)[2,2]


summarise.data <- mod.data %>% 
  dplyr::mutate(., slope = map_dbl(model, slope_fun),
            lower_ci = map_dbl(model, ci_lower_fun),
            upper_ci = map_dbl(model, ci_upper_fun))


# Alternative: plots by Y-axis
# 1
summarise.data.sp <- summarise.data %>% 
  ungroup(Length) %>% 
  mutate_at('Length', as.numeric) %>%
  split(list(summarise.data$Variables,
             summarise.data$Region))
   
# 2 Create plot function
plot.fun.slope <- function(.x,.y){
  ggplot(data=.x, aes(x = Length,y = slope))+
    geom_point() + 
    #geom_line()+
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    #geom_smooth(method='gam', formula= y~x)+
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ylab("Temporal slope")+
  xlab("Length group")+theme + theme + ggtitle(.y)
  }


# 3 plot with imap
purrr::imap(summarise.data.sp,plot.fun.slope)



```

# Plot individually
Export PDF 3  x 8
```{r}
# 1 Logit_Stan_SubArea_Length
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Logit_Stan_SubArea_Length")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Logit_Stan_SubArea_Length")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.08, 0, 0.08),
                     limits = c(-0.10,0.10)) +
  scale_x_discrete(limits = c(1,5,10,15,20))
  
 
# 2 Centroid_lon
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Centroid_lon")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Centroid_lon")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.10, 0, 0.10),
                     limits = c(-0.15,0.15)) +
  scale_x_discrete(limits = c(1,5,10,15,20))



# 3 Centroid_lat
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Centroid_lat")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Centroid_lat")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.10, 0, 0.10),
                     limits = c(-0.15,0.15)) +
  scale_x_discrete(limits = c(1,5,10,15,20))+
  xlab("Length group")

```


#----------------Table 1 Model ------------------
0. ts plot
1. Detrend response variable by differencing
2. Predictor:Remove colinearity by substracting mean (check)
3. Fit the model and perform acf(resid(fit))
4. Fit again the model with ARMA (gls or astsa)
5. Decide the best ARMA using AIC (& check whitness)
6. Parsimonious model for predictors 

# Prepare data
response use first difference
explanatory use scaled, except cpue_length log transform
```{r}

# 1 Take first diff, create ar1
cpue.length.year.ar <- cpue.length.year %>% 
  mutate_at("Length", as.factor) %>% 
  mutate_at("Num_SubArea_Length", as.numeric) %>% 
  group_by(Species, Region,Length) %>%
  # 1. AR subarea
  mutate(ar1_area = lag(Stan_SubArea_Length),
         diff_area = Stan_SubArea_Length - ar1_area,
         ar2_area = lag(ar1_area),
         ar3_area = lag(ar2_area),
         ar4_area = lag(ar3_area)) %>% 
  # 2. AR lon
  mutate(ar1_lon = lag(Centroid_lon),
         diff_lon = Centroid_lon - ar1_lon,
         ar2_lon = lag(ar1_lon),
         ar3_lon = lag(ar2_lon),
         ar4_lon = lag(ar3_lon)) %>% 
  # 3. AR lat
  mutate(ar1_lat = lag(Centroid_lat),
         diff_lat = Centroid_lat - ar1_lat,
         ar2_lat = lag(ar1_lat),
         ar3_lat = lag(ar2_lat),
         ar4_lat = lag(ar3_lat)) %>% 
  # ungroup
  ungroup() %>% 
  # 4. log CPUE_Length_Year
  mutate(log_cpue = log(CPUE_Length_Year)) %>% 
  # 5. Scale fishing, TSB
  mutate(s_tsb = scale_this(TSB_Tonnes),
         s_temp = scale_this(MeanBT),
         s_fmor = scale_this(Fishing_Mortality)) %>% 
  # Select variables
  select(Species,Region,Length,
         Stan_SubArea_Length,
         ar1_area,diff_area,ar2_area,ar3_area, ar4_area,
         ar1_lon, diff_lon, ar2_lon,ar3_lon, ar4_lon,
         ar1_lat, diff_lat, ar2_lat,ar3_lat, ar4_lat,
         log_cpue, s_tsb,s_temp,s_fmor) 
  
  
cpue.length.year.ar

```


# Functions
```{r}

# check_ar_range
check_ar_range <- function(dd){
  mm1<-lm(diff_area ~  ar1_area, dd,
        na.action = na.omit)
  mm2<-lm(diff_area ~  ar1_area + ar2_area ,
        dd, na.action = na.omit)
  mm3<-lm(diff_area ~ ar1_area + ar2_area +
        ar3_area, dd, na.action = na.omit)
  mm4<-lm(diff_area ~  ar1_area + ar2_area +
          ar3_area + ar4_area, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
}

# check_ar_lon
check_ar_lon <- function(dd){
  mm1<-lm(diff_lon ~  ar1_lon, dd,
        na.action = na.omit)
  mm2<-lm(diff_lon ~  ar1_lon + ar2_lon ,
        dd, na.action = na.omit)
  mm3<-lm(diff_lon ~ ar1_lon + ar2_lon +
        ar3_lon, dd, na.action = na.omit)
  mm4<-lm(diff_lon ~  ar1_lon + ar2_lon +
          ar3_lon + ar4_lon, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
  }


# check_ar_lat
check_ar_lat <- function(dd){
  mm1<-lm(diff_lat ~  ar1_lat, dd,
        na.action = na.omit)
  mm2<-lm(diff_lat ~  ar1_lat + ar2_lat ,
        dd, na.action = na.omit)
  mm3<-lm(diff_lat ~ ar1_lat + ar2_lat +
        ar3_lat, dd, na.action = na.omit)
  mm4<-lm(diff_lat ~  ar1_lat + ar2_lat +
          ar3_lat + ar4_lat, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
  }


# Build tibble
m.tibble <- function(model,col1,col2,
                      species,response){
  columns <- anova(model)[c(col1:col2),c(1:5)]
  Explanatory <- rownames(columns)
  R_square <- summary(model)$adj.r
  tibble(Species = species, 
         Response = response,
         Explanatory, columns, R_square)
  }


```

# Trial
```{r}

# Remove rows with na
dd.na <- dd %>% drop_na(x, all_of(x))

# autotorrelation 
m<- lm(diff_area ~ ar1_area + ar2_area + ar3_area +
     ar4_area, dd, na.action = na.exclude)
anova(m)
area_rauto <-residuals (m)
length(r_area)

# Partial Y
m <- lm(r_area ~ s_temp, dd, na.action = na.exclude)
area_rauto_rtemp <- residuals(m)
length(area_rauto_rtemp)

# Partial tsb
m <- lm(s_tsb ~ s_temp, dd, na.action = na.exclude)
tsb_rtemp <- residuals (m)
length(tsb_rtemp)

# Partial temp
m <- lm(s_temp ~ s_tsb, dd, na.action = na.exclude)
temp_rtsb <- residuals(m)

# Model
m <- lm(area_rauto_rtemp ~ dd$Length * tsb_rtemp )

m <- lm(area_rauto_rtemp ~ dd$log_cpue + tsb_rtemp)

m<- lm(area_rauto_rtemp ~ dd$Length * temp_rtsb)


m <- lm(dd$diff_area ~ dd$s_tsb + dd$s_temp)
vif(m)
anova(m)
summary(m)
dd


dd
length(dd$Length)
cor.test(dd$log_cpue, dd$s_tsb) 
cor.test(dd$s_temp, dd$s_tsb)


# Different order results in different outputs
dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

mf.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
       Length * s_tsb + Length * s_temp, dd)
vif(mf.cod.range)
summary(mf.cod.range)
anova(mf.cod.range)


mf.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
       Length * s_temp + Length * s_tsb, dd)
vif(mf.cod.range)
anova(mf.cod.range)


```





# Cod, individual range size
fit 4 ar, choose best.
correlation test of fishing & temp
when highly correlated, fit in separate models.
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# Correlation between temp & TSB
cor.test(dd$s_tsb,dd$s_temp) # -0.44
cor.test(dd$s_fmor,dd$s_temp) # -0.3
cor.test(dd$s_fmor,dd$s_tsb) # 0.47

# 1 Fit model with tsb
mf.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length * s_tsb, dd)
vif(mf.cod.range)
summary(mf.cod.range)
anova(mf.cod.range)

mf.cod.range.tibble <- 
  m.tibble(mf.cod.range,6,8,"Atlantic cod","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length * s_temp, dd)
vif(mt)
step(mt)

mt.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length , dd)
vif(mt.cod.range)
anova(mt.cod.range)
summary(mt.cod.range)

mt.cod.range.tibble <- 
  m.tibble(mt.cod.range,6,6,"Atlantic cod","range")

cod.range.tibble <- 
  rbind(mf.cod.range.tibble, mt.cod.range.tibble)     

#------------AR1----------------
# mf
mf.cod.range1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_tsb, dd)
vif(mf.cod.range1)
summary(mf.cod.range1)
anova(mf.cod.range1)

(mf.cod.range.tibble.ar <- 
  m.tibble(mf.cod.range1,2,5,"Atlantic cod","range"))

# mt
mt1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_temp, dd)
vif(mt1)
step(mt1)

mt.cod.range1 <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length , dd)
vif(mt.cod.range1)
anova(mt.cod.range1)
summary(mt.cod.range1)
(mt.cod.range.tibble.ar <- 
  m.tibble(mt.cod.range1,2,3,"Atlantic cod","range"))

# mm (fishing mortality)
mm.cod.range1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_fmor, dd)
vif(mm.cod.range1)
summary(mm.cod.range1)
anova(mm.cod.range1)



```


# Cod, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# Correlation between temp & TSB
## When highly correlated, fit seperate models
cor.test(cpue.length.year.ar$s_tsb,cpue.length.year.ar$s_temp)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
AIC(mf)
AIC(mf1)
AIC(mf2)
mf.cod.lon <- mf2

(mf.cod.lon.tibble <- 
  m.tibble(mf.cod.lon,5,5,"Atlantic cod","Lon"))


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
mt2 <- update(mt1,~.-s_temp)
anova(mt2)
summary(mt2)
mt.cod.lon <- mt2

(mt.cod.lon.tibble <- 
  m.tibble(mt.cod.lon,5,5,"Atlantic cod","Lon"))

cod.lon.tibble <- 
  rbind(mf.cod.lon.tibble, mt.cod.lon.tibble)       


#--------AR1
#mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
AIC(mfar)
AIC(mf1ar)
AIC(mf2ar)
mf.cod.lon <- mf2ar

(mf.cod.lon.tibble.ar <- 
  m.tibble(mf.cod.lon,2,2,"Atlantic cod","Lon"))

#mt
#@ Results different from AR4.
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.cod.lon <- mtar

(mt.cod.lon.tibble.ar <- 
  m.tibble(mt.cod.lon,2,4,"Atlantic cod","Lon"))

```


# Cod, latitudinal centroid
Not include log_cpue at the global model 
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)

# Correlation between temp & TSB
cor.test(cpue.length.year.ar$s_tsb,cpue.length.year.ar$s_temp)

# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)
step(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf.cod.lat <- mf1

mf.cod.lat.tibble <- m.tibble(mf.cod.lat,5,6,"Atlantic cod","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)

vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.cod.lat <- mt1

mt.cod.lat.tibble <- 
  m.tibble(mt.cod.lat,5,6,"Atlantic cod","Lat")


#----------AR1
# mf
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)
step(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf.cod.lat.ar <- mf1ar

(mf.cod.lat.tibble.ar <- m.tibble(mf.cod.lat.ar,2,3,"Atlantic cod","Lat"))

# mt
mtar <- lm(diff_lat ~ 
     ar1_lat +
     Length * s_temp, dd, na.action = na.omit)

vif(mtar)
summary(mtar)
anova(mtar)
mt1ar <- update(mtar,~.-Length:s_temp)
anova(mtar,mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.cod.lat.ar <- mt1ar

(mt.cod.lat.tibble.ar <- 
  m.tibble(mt.cod.lat.ar,2,3,"Atlantic cod","Lat"))

```


# Haddock, individual range size
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# Correlation between temp & TSB
cor.test(dd$s_tsb,dd$s_temp) # -0.33
cor.test(dd$s_fmor,dd$s_temp) # -0.32
cor.test(dd$s_fmor,dd$s_tsb) # 0.52

# 1 Fit model with tsb
mf <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length * s_tsb, dd)
summary(mf)
anova(mf)
step(mf)

mf1 <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_tsb, dd)
anova(mf1)
summary(mf1)
vif(mf1)
mf.had.range <- mf1

mf.had.range.tibble <- 
  m.tibble(mf.had.range,4,5,"Haddock","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_temp, dd)
anova(mt)
vif(mt)
step(mt)

mt1 <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1)
anova(mt1)
summary(mt1)
mt.had.range <- mt1


mt.had.range.tibble <- 
  m.tibble(mt.had.range,4,5,"Haddock","range")

had.range.tibble <- 
  rbind(mf.had.range.tibble, mt.had.range.tibble)     

#----------AR
# mf
mfar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_tsb, dd)
summary(mfar)
anova(mfar)
step(mfar)

mf1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_tsb, dd)
anova(mf1ar)
summary(mf1ar)
vif(mf1ar)
mf.had.range.ar <- mf1ar

(mf.had.range.tibble.ar <- 
  m.tibble(mf.had.range.ar,2,4,"Haddock","range"))


# mt
mtar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_temp, dd)
anova(mtar)
vif(mtar)
step(mtar)

mt1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.had.range.ar <- mt1ar


(mt.had.range.tibble.ar <- 
  m.tibble(mt.had.range.ar,2,4,"Haddock","range"))

# mm
mmar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_fmor, dd)
summary(mmar)
anova(mmar)
step(mmar)

```


# Haddock, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
AIC(mf)
AIC(mf1)
AIC(mf2)
mf.had.lon <- mf2

mf.had.lon.tibble <- 
  m.tibble(mf.had.lon,5,5,"Haddock","Lon")


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.had.lon <- mt1

mt.had.lon.tibble <- 
  m.tibble(mt.had.lon,5,6,"Haddock","Lon")

had.lon.tibble <- 
  rbind(mf.had.lon.tibble, mt.had.lon.tibble)       

#---------AR
# mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
mf.had.lon.ar <- mf2ar

(mf.had.lon.tibble.ar <- 
  m.tibble(mf.had.lon.ar,2,2,"Haddock","Lon"))


# mt
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt1ar <- update(mtar,~.-Length:s_temp)
anova(mtar,mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.had.lon.ar <- mt1ar

(mt.had.lon.tibble.ar <- 
  m.tibble(mt.had.lon.ar,2,3,"Haddock","Lon"))

```


# Haddock, latitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)


# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)


mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
mf2<- update(mf1,~.-s_tsb)
summary(mf2)
anova(mf2)
mf.had.lat <- mf2

mf.had.lat.tibble <- m.tibble(mf.had.lat,5,5,"Haddock","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.had.lat <- mt1

mt.had.lat.tibble <- 
  m.tibble(mt.had.lat,5,6,"Haddock","Lat")
            
had.lat.tibble <- rbind(mf.had.lat.tibble,
                   mt.had.lat.tibble)       

#----------AR
# 1 Fit full model with tsb
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)


mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
mf2ar<- update(mf1ar,~.-s_tsb)
summary(mf2ar)
anova(mf2ar)
mf.had.lat.ar <- mf2ar

(mf.had.lat.tibble.ar <- m.tibble(mf.had.lat.ar,2,2,"Haddock","Lat"))


# 2 Fit full model with temp
#@ results different from AR4
#@ in summary, temp only influence large groups
mtar <- lm(diff_lat ~ 
     ar1_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.had.lat.ar <- mtar

(mt.had.lat.tibble.ar <- 
  m.tibble(mt.had.lat.ar,2,4,"Haddock","Lat"))

```


# Whiting, individual range size
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# correlation
cor.test(dd$s_tsb,dd$s_temp) # -0.16
cor.test(dd$s_fmor,dd$s_temp) # -0.23
cor.test(dd$s_fmor,dd$s_tsb) # 0.67

# 1 Fit model with tsb
mf <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_tsb, dd)
summary(mf)
anova(mf)
step(mf)

mf1 <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_tsb, dd)
anova(mf1)
summary(mf1)
vif(mf1)
mf.whi.range <- mf1

mf.whi.range.tibble <- 
  m.tibble(mf.whi.range,4,5,"Whiting","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_temp, dd)
anova(mt)
vif(mt)
step(mt)

mt1 <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1)
anova(mt1)
summary(mt1)
AIC(mt)
AIC(mt1)
anova(mt)
summary(mt)
mt.whi.range <- mt # include interaction term


mt.whi.range.tibble <- 
  m.tibble(mt.whi.range,4,6,"Whiting","range")

whi.range.tibble <- 
  rbind(mf.whi.range.tibble, mt.whi.range.tibble)     

#-----------AR
# mf
mfar <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_tsb, dd)
summary(mfar)
anova(mfar)
step(mfar)

mf1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_tsb, dd)
anova(mf1ar)
summary(mf1ar)
vif(mf1ar)
mf.whi.range.ar <- mf1ar

(mf.whi.range.tibble.ar <- 
  m.tibble(mf.whi.range.ar,2,4,"Whiting","range"))


# mt
mtar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_temp, dd)
anova(mtar)
summary(mtar)
vif(mtar)
step(mtar)
mt.whi.range.ar <- mtar

mt.whi.range.tibble.ar <- 
  m.tibble(mt.whi.range.ar,2,5,"Whiting","range")


# mm
mm <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_fmor, dd)
summary(mm)
anova(mm)


```


# Whiting, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
mf.whi.lon <- mf2

mf.whi.lon.tibble <- 
  m.tibble(mf.whi.lon,5,5,"Whiting","Lon")


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt.whi.lon <- mt

mt.whi.lon.tibble <- 
  m.tibble(mt.whi.lon,5,7,"Whiting","Lon")

whi.lon.tibble <- 
  rbind(mf.whi.lon.tibble, mt.whi.lon.tibble)  


#------------AR
# mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
mf.whi.lon.ar <- mf2ar

(mf.whi.lon.tibble.ar <- 
  m.tibble(mf.whi.lon.ar,2,2,"Whiting","Lon"))


# mt
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.whi.lon.ar <- mtar

(mt.whi.lon.tibble.ar <- 
  m.tibble(mt.whi.lon.ar,2,4,"Whiting","Lon"))

```


# Whiting, latitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)


# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)


mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
mf2<- update(mf1,~.-s_tsb)
summary(mf2)
anova(mf2)
mf.whi.lat <- mf2

mf.whi.lat.tibble <- m.tibble(mf.whi.lat,5,5,"Whiting","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)

mt.whi.lat <- mt

mt.whi.lat.tibble <- 
  m.tibble(mt.whi.lat,5,7,"Whiting","Lat")
            
whi.lat.tibble <- rbind(mf.whi.lat.tibble,
                   mt.whi.lat.tibble)       

#--------------AR
# mf
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)


mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar<- update(mf1ar,~.-s_tsb)
summary(mf2ar)
anova(mf2ar)
mf.whi.lat.ar <- mf2ar

(mf.whi.lat.tibble.ar <- m.tibble(mf.whi.lat.ar,2,2,"Whiting","Lat"))


# mt
mtar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)

mt.whi.lat.ar <- mtar

(mt.whi.lat.tibble.ar <- 
  m.tibble(mt.whi.lat.ar,2,4,"Whiting","Lat"))
            
```

# Statistic summary AR1
```{r}

stat.summary.ar1 <-rbind(
mt.cod.range.tibble.ar,
mf.cod.range.tibble.ar,
mt.cod.lon.tibble.ar1,
mf.cod.lon.tibble.ar1,
mt.cod.lat.tibble.ar,
mf.cod.lat.tibble.ar,
mt.had.range.tibble.ar,
mf.had.range.tibble.ar,
mt.had.lon.tibble.ar,
mf.had.lon.tibble.ar,
mt.had.lat.tibble.ar,
mf.had.lat.tibble.ar,
mt.whi.range.tibble.ar,
mf.whi.range.tibble.ar,
mt.whi.lon.tibble.ar,
mf.whi.lon.tibble.ar,
mt.whi.lat.tibble.ar,
mf.whi.lat.tibble.ar
)

write.csv (stat.summary.ar1, file = "stat.summary.ar1.csv")

```


# Plot cod subarea model 
```{r}
dd
ggplot(dd, aes(y = Stan_SubArea_Length, x = s_tsb, color = Length))+
  geom_smooth(method = "lm", se =  F)+
  geom_point()+ xlim(2,-2)+
  scale_colour_viridis_d()+ theme

ggplot(dd, aes(y = Stan_SubArea_Length, 
               x = s_temp, color = Length))+
  geom_point()+ theme+
  scale_colour_viridis_d()+
  geom_smooth(method = "lm", se =  F,
              color = "black",lty = 2)
  

```




# Cod,distribution range_trials
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


# Plot non-transformed and transformed variables
## Response variable
plot(dd$Num_SubArea_Length ~ dd$Year)
plot(dd$Centroid_lon~ dd$Year)
plot(dd$Centroid_lat~ dd$Year)

## Predictor
### log transform cpue
plot(dd$CPUE_Length_Year ~ dd $Year)
plot(log(dd$CPUE_Length_Year) ~ dd $Year) 
plot(dd$Fishing_Mortality ~ dd$Year)
plot(dd$MeanBT_scale ~ dd$Year)
plot(dd$TSB_Tonnes ~ dd$Year)

## Transformed variables
plot(dd$Diff_Num_SubArea_Length ~ dd$Year)
plot(dd$Diff_Centroid_lon~ dd$Year)
plot(dd$Diff_Centroid_lat~ dd$Year)
plot(dd$CPUE_Length_Year_scale_log ~ dd $Year)
plot(dd$Fishing_Mortality_scale ~ dd$Year)
plot(dd$MeanBT_scale ~ dd$Year)
plot(dd$TSB_Tonnes_scale ~ dd$Year)

# 5 Check colinearity of predictors
dd <- dd %>% 
  ungroup() %>% 
  select(Year,Length, Diff_Num_SubArea_Length,
         Diff_Centroid_lon,Diff_Centroid_lat,
         CPUE_Length_Year_scale_log,
         Fishing_Mortality_scale,
         MeanBT_scale, TSB_Tonnes_scale) %>% 
  mutate_at("Length", as.factor)

pairs(dd[,6:7])
cor.test(dd$Diff_Centroid_lon,dd$MeanBT_scale)

library(PerformanceAnalytics)
chart.Correlation(dd[,3:9], histogram=TRUE, pch=19)
cor.test(dd$MeanBT_scale, dd$TSB_Tonnes_scale)
## The highest correlation coefficient isx ~0.5
## It seems that it is not too high, so I can still fit
## all predictors as its original forms.


m<- lm(Diff_Num_SubArea_Length ~ 
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale, dd)

anova(m)
library(car)
vif(m)

## vif of two predictors are at the border line,
## but it is still ok to fit the original form.

# 6 Fit AR and select best AR
## 6.1 acf of residuals of fitted full model

acf(resid(m)) # indicate AR1
acf(residuals(m),type = "partial",na.action = na.omit) #indicate AR1
library(astsa)

## 6.2 acf of response variable without predictors
acf(dd$Diff_Num_SubArea_Length, na.action = na.omit) #indicate AR1

m0 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit)
m1 <- gls(Diff_Num_SubArea_Length~Length,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=1))
m2 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=2))
m3 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=3))
m21 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=2,q = 1))
acf(resid(m21))

anova(m0,m1,m2,m3,m21) # for AIC, AR2 seems to be the best

sarima(dd$Diff_Num_SubArea_Length,1,0,0) # AR1
sarima(dd$Diff_Num_SubArea_Length,2,0,0) # AR2 is better than AR1

sarima(dd$Diff_Num_SubArea_Length,2,0,0,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale,
               dd$MeanBT_scale))

sarima(dd$Diff_Num_SubArea_Length,2,1,1,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale,
               dd$MeanBT_scale))


# 7 Fit selected AR and all predictors
dd<- dd %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Length", as.factor)


mf0<- gls(Diff_Num_SubArea_Length ~ 
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale, 
     dd, na.action = na.omit)

mf1_nogroup <- update(mf0,correlation = 
                corARMA(p = 1, q = 0))


mf1 <- update(mf0,correlation = 
                corARMA(form = ~ Year | Length , 
                        p = 1, q = 0))

mf2 <- update(mf0,correlation = corARMA(form = ~ Year | Length , p = 2, q = 0))


anova(mf0)
summary(mf0)
anova(mf1)
summary(mf1)
anova(mf2)
summary(mf2)
AIC(mf0,mf1,mf1_nogroup,mf2)


plot(resid(mf0),fitted(mf0))
plot(resid(mf1),fitted(mf1))
plot(resid(mf1_nogroup),fitted(mf1_nogroup))
plot(resid(mf2),fitted(mf2))


# 8 Parsimonious model
## 8.1 with AR1
anova(mf1)
mf1.1 <-update(mf1,~.- Length:MeanBT_scale)
anova(mf1.1)
mf1.2 <- update(mf1.1,~.-Length:TSB_Tonnes_scale)
anova(mf1.2)
mf1.3 <- update(mf1.2,~.-MeanBT_scale)
anova(mf1.3)

sarima(dd$Diff_Num_SubArea_Length,2,0,0,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale))

## 8.2 with AR2
anova(mf2)
mf2.1<-update(mf2,~.-Length:TSB_Tonnes_scale)
anova(mf2.1)
mf2.2 <- update(mf2.1,~.-TSB_Tonnes_scale)
anova(mf2.2)
mf2.3 <- update(mf2.2,~.-Length:MeanBT_scale)
anova(mf2.3)
mf2.4 <- update(mf2.3,~.-MeanBT_scale)
anova(mf2.4)
mf2.5 <- update(mf2.4,~.-CPUE_Length_Year_scale_log)
anova(mf2.5)
plot(mf.5)
AIC(mf0,mf1,mf1.1,mf1.2,mf1.3,mf2)
acf(resid(m1))
acf(dd$Diff_Num_SubArea_Length, na.action = na.omit)

dd10<- dd %>% 
  filter(Length =="10")

m<- lm(Diff_Num_SubArea_Length ~ Length,dd)
anova(m)
plot(dd$Length,dd$Diff_Num_SubArea_Length)

### Final model:mf1.3
anova(mf1.3)
summary(mf1.3)


plot(dd10$Num_SubArea_Length,dd10$lag_Num_SubArea_Length)
acf(dd10$Num_SubArea_Length)
acf(resid(mf1.3))


# Fit AR as predictor in lm model
dd1 <- dd %>% 
  filter(Length =="1")
dd2 <- dd %>% 
  filter(Length =="2")

mm1<-lm(Diff_Num_SubArea_Length ~ Length + lag_Num_SubArea_Length,dd)

mm2<-lm(Diff_Num_SubArea_Length ~ Length + lag_Num_SubArea_Length +
         lag2_Num_SubArea_Length,dd)

anova(mm1)  
AIC(mm1,mm2)
plot(mm1)
E <- acf(resid(lm))
coplot(resid(lm)~fitted(lm)|Length,)


plot(fitted(lm),resid(lm))
plot(dd$Length,dd$Stan_SubArea_Length)


# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.32
summary(mm3) # r2 = 0.38 
summary(mm4) # r2 = 0.39


m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

AIC(m)
anova(m)
plot(m)
acf(resid(m))
plot(dd$Stan_SubArea_Length~dd$TSB_Tonnes_scale)

# mf<- gls(Diff_Stan_SubArea_Length ~ 
#        CPUE_Length_Year_scale_log+
#        Length * TSB_Tonnes_scale +
#        Length * MeanBT_scale,
#        correlation = corARMA(form = ~ Year | Length , p = 3, q = 0), 
#      dd, na.action = na.omit)
# anova(mf)
# 
# acf(resid(mf))





# Check AR with individual length
dd5 <- dd %>% 
  filter(Length =="5")

mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd5, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd5,
         na.action = na.omit)

AIC(mm1)
AIC(mm2)
AIC(mm3)
AIC(mm4)
summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.32
summary(mm3) # r2 = 0.38 
summary(mm4) # r2 = 0.39

dd5 <- dd %>% 
  filter(Length =="19")
m5 <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length
#    lag2_Stan_SubArea_Length+
      #lag3_Stan_SubArea_Length 
#      lag4_Stan_SubArea_Length 
     #CPUE_Length_Year_scale_log +
      #TSB_Tonnes_scale +
      #MeanBT_scale,
      ,dd5)
acf(resid(m5))
AIC(m5)


m5 <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length+
 lag4_Stan_SubArea_Length 
     #CPUE_Length_Year_scale_log +
      #TSB_Tonnes_scale +
      #MeanBT_scale,
      ,dd5)



cor.test(dd$MeanBT, dd$TSB_Tonnes)

```



# Cod,Diff_Centroid_lon: 
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.29
summary(mm2) # r2 = 0.30
summary(mm3) # r2 = 0.317
summary(mm4) # r2 = 0.314
AIC(mm1) # 3261
AIC(mm2) # 3191
AIC(mm3) # 3120
AIC(mm4) # 3054

## From best to worst: mm3/mm4>mm2>mm1


#2 Check AR with length subset (Length = 0, 5, 15,19)
dd5 <- dd %>% 
  filter(Length =="19")


mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.28 # 0.18 # 0.37 # 0.37
summary(mm2) # r2 = 0.30 # 0.19 # 0.43 # 0.43
summary(mm3) # r2 = 0.33 # 0.19 # 0.46 # 0.46
summary(mm4) # r2 = 0.31 # 0.24 # 0.46 # 0.46

AIC(mm1) # 172 # 160 # 118 # 154
AIC(mm2) # 170 # 158 # 114 # 149
AIC(mm3) # 166 # 158 # 112 # 146
AIC(mm4) # 165 # 154 # 112 # 145

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3 > mm4/mm2 > mm1


# 3 Fit full model with best AR (AR3)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-TSB_Tonnes_scale)
anova(m4)
summary(m4) #r2=0.31
AIC(m4) #3120
# Double check AR
m5<- update(m4,~.-lag3_Centroid_lon)
m6 <- update(m5,~.-lag2_Centroid_lon)
summary(m5) # r2=0.30
summary(m6) # r2=0.29
AIC(m5) # AIC 3192
AIC(m6) # AIC 3261

# Final:m4 has min AIC,max R2
anova(m4)
summary(m4)
```


# Cod,Diff_Centroid_lat: 
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.34
summary(mm2) # r2 = 0.38
summary(mm3) # r2 = 0.38
summary(mm4) # r2 = 0.38
AIC(mm1) # 2363
AIC(mm2) # 2259
AIC(mm3) # 2204
AIC(mm4) # 2165

## From best to worst: mm4>mm3>mm2>mm1


#2 Check AR with length subset (Length = 0, 5)
dd5 <- dd %>% 
  filter(Length =="5")


mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.29 # 0.18
summary(mm2) # r2 = 0.37 # 0.39
summary(mm3) # r2 = 0.38 # 0.39
summary(mm4) # r2 = 0.39 # 0.40

AIC(mm1) # 65.47 # 91
AIC(mm2) # 61.1 # 72
AIC(mm3) # 60.5 # 71
AIC(mm4) # 61.5 # 72

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3 > mm4> mm2 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale)
anova(m1)
m2 <- update(m1,~.-Length:TSB_Tonnes_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-CPUE_Length_Year_scale_log)
anova(m4) 
summary(m4) # 0.43
AIC(m4) # 1999

# 5 Double check AR
m5 <- update(m4,~.-lag3_Centroid_lat)
m6 <- update(m5,~.-lag2_Centroid_lat)
summary(m5) # 0.43
summary(m6) # 0.43
AIC(m5) # 2036
AIC(m6) # 2093


## final model: m4 same R2 min AIC
anova(m4)
summary(m4)
ggplot(dd,aes(x = TSB_Tonnes_scale, y = Centroid_lat))+
  geom_point()+
  facet_wrap("Length")


```

# Haddock, distribution range: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock

#1 Check AR with full dataset using AIC and R2
# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.18
summary(mm2) # r2 = 0.23
summary(mm3) # r2 = 0.23
summary(mm4) # r2 = 0.24
AIC(mm1) # -829
AIC(mm2) # -889
AIC(mm3) # -863
AIC(mm4) # -872

## Best : Not obvious, mm2 

#2 Check AR with length subset (Length = 0, 5, 15, )
dd5 <- dd %>% 
  filter(Length =="0")

mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd5, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.28 # 0.12 # 0.18
summary(mm2) # r2 = 0.29 # 0.15 # 0.19
summary(mm3) # r2 = 0.28 # 0.15 # 0.18
summary(mm4) # r2 = 0.30 # 0.25 # 0.18

AIC(mm1) # 2.1 # -75 # -74
AIC(mm2) # 4.9 # -73 # -70
AIC(mm3) # 7.6 # -68 # -66
AIC(mm4) # 8.7 # -70 # -62

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## Not clear, mm1


# 3 Fit full model with best AR 
## As AR 1-4 seems similar, fit AR4, then trimming 

m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-lag4_Stan_SubArea_Length)
anova(m4)
plot(m4)
AIC(m4) # -1296

# 5 Check other AR
m5 <- update(m4,~.-lag4_Stan_SubArea_Length)
m6 <- update(m5,~.-lag3_Stan_SubArea_Length)
m7 <- update(m6,~.-lag2_Stan_SubArea_Length)
m8 <- update(m7,~.-lag1_Stan_SubArea_Length)
AIC(m5) # -1296
AIC(m6) # -1319
AIC(m7) # -1231
AIC(m8) # -1231
## final model: m6 (AR2)
anova(m6)
summary(m6)
```

# Haddock,Diff_Centroid_lon: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.37
summary(mm2) # r2 = 0.40
summary(mm3) # r2 = 0.41
summary(mm4) # r2 = 0.41
AIC(mm1) # 2689
AIC(mm2) # 2593
AIC(mm3) # 2529
AIC(mm4) # 2451

## best: not clear, mm4


#2 Check AR with length subset (Length = 0, 15)
dd5 <- dd %>% 
  filter(Length =="0")


mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.61 # 0.34
summary(mm2) # r2 = 0.65 # 0.45
summary(mm3) # r2 = 0.64 # 0.56
summary(mm4) # r2 = 0.64 # 0.55

AIC(mm1) # 94
AIC(mm2) # 90
AIC(mm3) # 90
AIC(mm4) # 90

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3/mm4


# 3 Fit full model with AR4 as not clear which AR is best

m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
      lag4_Centroid_lon+
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)

# 5 Double check AR
m3 <- update(m2,~.-lag4_Centroid_lon)
m4 <- update(m3,~.-lag3_Centroid_lon)
m5 <- update(m4,~.-lag2_Centroid_lon)
m6 <- update(m5,~.-lag_Centroid_lon)
AIC(m2) # 2274
AIC(m3) # 2347 
AIC(m4) # 2409
AIC(m5) # 2497
AIC(m6)
## final model: m2 (AR4)
anova(m2)
summary(m2)

```

# Haddock,Diff_Centroid_lat: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.31
summary(mm2) # r2 = 0.35
summary(mm3) # r2 = 0.38
summary(mm4) # r2 = 0.36
AIC(mm1) # 1662
AIC(mm2) # 1582
AIC(mm3) # 1515
AIC(mm4) # 1478

## mm3/mm4


# #2 Check AR with length subset (Length = 0, 5)
# dd5 <- dd %>% 
#   filter(Length =="5")
# 
# 
# mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat+
#           lag4_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.29 # 0.18
# summary(mm2) # r2 = 0.37 # 0.39
# summary(mm3) # r2 = 0.38 # 0.39
# summary(mm4) # r2 = 0.39 # 0.40
# 
# AIC(mm1) # 65.47 # 91
# AIC(mm2) # 61.1 # 72
# AIC(mm3) # 60.5 # 71
# AIC(mm4) # 61.5 # 72
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))


# 3 Fit full model with highest AR

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
      lag4_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale)
anova(m2)
m3 <- update(m2,~.- TSB_Tonnes_scale)
anova(m3)

# 5 Double check AR
m4 <- update(m3,~.-lag4_Centroid_lat)
m5 <- update(m4,~.-lag3_Centroid_lat)
m6 <- update(m5,~.-lag2_Centroid_lat)
m7 <- update(m6,~.-lag_Centroid_lat)

AIC(m3) # 1381
AIC(m4) # 1418
AIC(m5) # 1483
AIC(m6) # 1566
AIC(m7) # 1887

## m3 is the best (AR4)
anova(m3)
summary(m3)

```

# Whiting, distribution range: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting

#1 Check AR with full dataset using AIC and R2
# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.18
summary(mm3) # r2 = 0.19
summary(mm4) # r2 = 0.19
AIC(mm1) # -976
AIC(mm2) # -951
AIC(mm3) # -930
AIC(mm4) # -918

## From best to worst: mm4

#2 Check AR with length subset (Length = 0, 5, 15, )
# dd5 <- dd %>% 
#   filter(Length =="15")
# 
# mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
#         na.action = na.omit)
# 
# mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length,dd5, na.action = na.omit)
# 
# mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
#           lag4_Stan_SubArea_Length,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.41 # 0.28 # 0.09
# summary(mm2) # r2 = 0.49 # 0.40 # 0.12
# summary(mm3) # r2 = 0.63 # 0.48 # 0.17
# summary(mm4) # r2 = 0.64 # 0.51 # 0.29
# 
# AIC(mm1) # -4.06 #-34.6 # -39
# AIC(mm2) # -8.2  # -40.8 # -37.30
# AIC(mm3) # -18.56  #-43.5 # -37.36
# AIC(mm4) # -16.8 # -42.1 # -40.18
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))

## mm3 > mm2/mm4 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale )
anova(m1)
m2 <- update(m1,~.-Length:TSB_Tonnes_scale)
anova(m2)
m3 <- update(m2,~.-lag3_Stan_SubArea_Length)
anova(m3)
m4 <- update(m3,~.-lag4_Stan_SubArea_Length)
anova(m4)

# 5 Check other AR
m5 <- update(m4,~.-lag2_Stan_SubArea_Length)
m6 <- update(m5,~.-lag1_Stan_SubArea_Length)
AIC(m4) # -852
AIC(m5) # -849
AIC(m6) # -849

# Final m4 with lowest AIC
anova(m4)
summary(m4)

```

# Whiting,Diff_Centroid_lon: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.4
summary(mm2) # r2 = 0.4
summary(mm3) # r2 = 0.4
summary(mm4) # r2 = 0.4
AIC(mm1) # 2915
AIC(mm2) # 2859
AIC(mm3) # 2799
AIC(mm4) # 2738

## Best:mm4


#2 Check AR with length subset (Length = 0, 5, 15,19)
# dd5 <- dd %>% 
#   filter(Length =="19")
# 
# 
# mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon+lag3_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon+lag3_Centroid_lon+
#           lag4_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.28 # 0.18 # 0.37 # 0.37
# summary(mm2) # r2 = 0.30 # 0.19 # 0.43 # 0.43
# summary(mm3) # r2 = 0.33 # 0.19 # 0.46 # 0.46
# summary(mm4) # r2 = 0.31 # 0.24 # 0.46 # 0.46
# 
# AIC(mm1) # 172 # 160 # 118 # 154
# AIC(mm2) # 170 # 158 # 114 # 149
# AIC(mm3) # 166 # 158 # 112 # 146
# AIC(mm4) # 165 # 154 # 112 # 145
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))

## mm3 > mm4/mm2 > mm1


# 3 Fit full model with highest AR


m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
      lag4_Centroid_lon +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-MeanBT_scale)
anova(m2)
m3 <- update(m2,~.-CPUE_Length_Year_scale_log)
anova(m3)
m4 <- update(m3,~.-TSB_Tonnes_scale)
anova(m4)

# 5 Double check AR
m5 <- update(m4,~.-lag4_Centroid_lon)
m6 <- update(m5,~.-lag3_Centroid_lon)
m7 <- update(m6,~.-lag2_Centroid_lon)
m8 <- update(m7,~.-lag_Centroid_lon)

AIC(m4) # 2686
AIC(m5) # 2747
AIC(m6) # 2804
AIC(m7) # 2859
summary(m4) # R2= 0.45
summary(m5) # r2 = 0.45
summary(m6) # r2 = 0.44
summary(m7) # r2 = 0.44

# final: m4 (AR4) has the lowest AIC
anova(m4)
summary(m4)




```

# Whiting,Diff_Centroid_lat: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.34
summary(mm2) # r2 = 0.35
summary(mm3) # r2 = 0.36
summary(mm4) # r2 = 0.37
AIC(mm1) # 2500
AIC(mm2) # 2436
AIC(mm3) # 2368
AIC(mm4) # 2315

## mm4 best


#2 Check AR with length subset (Length = 0, 5)
# dd5 <- dd %>% 
#   filter(Length =="5")
# 
# 
# mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat+
#           lag4_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.29 # 0.18
# summary(mm2) # r2 = 0.37 # 0.39
# summary(mm3) # r2 = 0.38 # 0.39
# summary(mm4) # r2 = 0.39 # 0.40
# 
# AIC(mm1) # 65.47 # 91
# AIC(mm2) # 61.1 # 72
# AIC(mm3) # 60.5 # 71
# AIC(mm4) # 61.5 # 72
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))
# 
# ## mm3 > mm4> mm2 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
      lag4_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale)
anova(m1)
m2 <- update(m1,~.-MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-Length:TSB_Tonnes_scale)
anova(m3)
m4 <- update(m3,~.-Length )
anova(m4)
m5 <- update(m4,~.-TSB_Tonnes_scale)
anova(m5)


# 5 Double check AR

m6 <- update(m5,~.-lag4_Centroid_lat)
m7 <- update(m6,~.-lag3_Centroid_lat)
m8 <- update(m7,~.-lag2_Centroid_lat)
m9 <- update(m8,~.-lag_Centroid_lat)

AIC(m5) # 2338
AIC(m6) # 2403
AIC(m7) # 2503
AIC(m8) # 2632
AIC(m9) # 2837

## final model: m5 (AR4) with lowest AIC
anova(m5)
summary(m5)

cpue.length.cod %>% 
  group_by(Year) %>%
  tally()
  
```





#------------Supplementary------------

# Fig S1 body size structure with extreme body size limits
```{r}

# q.limit has info of quantile length
q.limit

## function to plot all species
plot.age.structure <- function(species) {
  lim <- q.limit %>% filter(Species == species)
  cpue.lngt.yearqua.before.cut %>%
  filter(Species == species) %>%
  ggplot (aes(x = as.numeric(LngtClass), y = Denstiy_CPUE_Lngt_Yearqua))+
  geom_line()+
  facet_wrap(~YearQua, ncol = 9)+
    geom_vline(xintercept = lim$Lower_limit,
             linetype="dotted", 
             color = "blue", size=1)+
    geom_vline(xintercept = lim$Upper_limit,
             linetype="dotted", 
             color = "blue", size=1)+
    theme(axis.text.x = element_text(angle=45),
          panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    theme+
  ggtitle(species)+xlab("Length (cm)") +
    ylab("Abundance density (%)")+
    xlab("body length (mm)")
  }


plot.age.structure("Atlantic cod")
plot.age.structure("Haddock")
plot.age.structure("Whiting")


cpue.lngt.yearqua %>% 
  group_by(Species,Region) %>% 
  summarise(min_len = min(LngtClass),
            max_len = max(LngtClass))
  
  
```

# Fig S4 plot stock biomass & temperature over time
Save as PDF, 3 x 7
```{r}
# TSB ~ Year
p1 <- cpue.year %>% 
  ggplot(aes(y = TSB_Tonnes / 1000000,
             x = Year,
             color = Species))+
           geom_point()+ geom_line()+
  xlab("Year")+ 
  ylab("Total stock biomass (million tonne)")+
   theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        legend.title = element_blank(),
        legend.position = c(.82,.82),
        strip.text.x = element_text(size = 11),
        legend.background = element_blank())+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14)) + ylim(0,2.5) +
  annotate("text", x=1977, y=2.5, label= "(a)") 

# Temperature ~ Year
p2 <- cpue.year %>% 
  ggplot(aes(y = MeanBT,
             x = Year))+
           geom_point()+ geom_line()+
  xlab("Year")+ 
  ylab(expression
       (Sea~bottom~temperature~(""^o~C)))+
   theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        legend.title = element_blank(),
        #legend.position = c(.82,.82),
        strip.text.x = element_text(size = 11))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14)) + ylim(3,8)+
  annotate("text", x=1977, y=8, label= "(b)")

# Align two graphs
require(gridExtra)
grid.arrange(p1, p2, ncol=2)

```


#--------------- Suppl cod subpopulation -----------------
# Divide into 
```{r}

```


#---------Other results-----------

# How long have fish moved
```{r}
dd <- cpue.length.year %>% 
  group_by(Region,Species,Year,Length) %>% 
  summarise(Mean_lon = mean(Centroid_lon),
            Mean_lat = mean(Centroid_lat))

dd.cod <- dd %>% 
  filter(Species == "Atlantic cod")
ggplot(dd.cod, aes(x = Year, y = Mean_lat))+
  geom_point()+
  facet_wrap(~Length+Species)+
  geom_smooth()

```


# Plot CPUE, Home range
```{r eval = FALSE}

# Plot CPUE & home range over time
# 1 create a function
plot.fun <- function(.x,.y){
  ggplot(data = .x, aes(x = YearQua, y = value))+
  facet_wrap(~Species, scales = "free")+
  geom_point() +xlab("Year-Quarter")+
  geom_smooth(method = "lm")+  
  ggtitle("Species CPUE over landscape")+
  theme + ggtitle(.y)
}

#2 gather 
cpue.year.gather <- cpue.year %>% 
  gather(key="Variables", value="value",
         log_CPUE_Year, Number_Subarea_All_Length) 

# 3 split, imap
cpue.year.gather %>% 
  ungroup(YearQua) %>%
  mutate_at('YearQua',as.numeric) %>% 
  split(list(cpue.year.gather$Variables, 
             cpue.year.gather$Region)) %>% 
  imap (.,plot.fun)


# Population home range ~ Population CPUE
plot.fun <- function(.x,.y){
  ggplot(data = .x, aes(x = log(CPUE_Year), 
                        y = Number_Subarea_All_Length,
                        color=Species))+
  geom_point()+
  stat_smooth(method ="lm")+
    xlab("Population size (logged CPUE)")+
    ylab("Home range (number of grid cells)")+
  theme + ggtitle(.y)
}

cpue.year %>% 
  split(cpue.year$Region) %>% 
  imap(.,plot.fun)


```


# Plot regional size indices over time
Add "free_y" to facet_wrap or not has very different visual effect
```{r}

## Create a function
plot.structure <- function(.x,.y){
  ggplot(data=.x, aes(x=YearQua,y=value))+
    geom_point()+
    geom_smooth(method='lm', formula= y~x)+
    facet_wrap(~Species,scales= "free_y")+   
    xlab("Year-Quarter") + theme + ggtitle(paste0(.y),"at regional scale")
  }


## gather
cpue.year.gather <- cpue.year %>% 
  ungroup() %>% 
  mutate_at('YearQua',as.numeric) %>% 
  group_by(Species, YearQua) %>% 
  gather(key="Variables", value="value", 
         Regional_size_richness,Regional_Shannon,Regional_mean_size,
         # The following three may not be computed 
         # because of limited memory
         #median_data, skewness_data, kurtosis_data,
         factor_key = TRUE) 

# split, imap
cpue.year.gather %>% 
  split(list(cpue.year.gather$Variables,
             cpue.year.gather$Region)) %>% 
  imap(.,plot.structure)


```








#----------------------------------------
# Plot intersect & union
```{r}  

## Create a function
plot.structure <- function(.x,.y){
  ggplot(data=.x, aes(x=YearQua,y=value))+
    geom_point()+
    #geom_smooth(method='lm', formula= y~x)+
    facet_wrap(~Species,scales= "free_y")+   
    xlab("Year-Quarter") + theme + ggtitle(paste0(.y),"at regional scale")
  }


## gather
cpue.year.gather <- cpue.year %>% 
  ungroup() %>% 
  mutate_at('YearQua',as.numeric) %>% 
  group_by(Species, YearQua) %>% 
  gather(key="Variables", value="value", 
         Mean_intersect,Mean_union,
         factor_key = TRUE) 

# split, imap
cpue.year.gather %>% 
  split(list(cpue.year.gather$Variables,
             cpue.year.gather$Region)) %>% 
  imap(.,plot.structure)

```




# Plot effect size slope of overlap & local shannon~time
- Big diff. between local & regional Shannon, probably because of high heterogeneity in local diversity.
- Lower overlap does not have lower CV, probably because habitat shrinks and seperate at the same time.
```{r}

theme <- 
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"),
    legend.position="none")


# Model overlap & local Shannon ~ time
#1 Use gather to create a column with all Y-variables
cpue.year.gather <- cpue.year %>% 
  gather(key = "Variables", value = "value",
         Paired_habitat_overlap, 
         #Local_Shannon, 
         #Local_size_richness, 
         #Local_mean_size ,
         Regional_Shannon, 
         Regional_size_richness,
         Regional_mean_size, 
         Paired_habitat_overlap_deno, 
         Mean_paired_lon_distance,
         Mean_paired_lat_distance,
         factor_key = TRUE)


cpue.year.gather.nest <- cpue.year.gather %>% 
  ungroup(YearQua) %>% 
  mutate_at('YearQua', as.numeric) %>% 
  group_by(Region, Species, Variables) %>% 
  nest()

#2 Fit function
mod_fun <-function(df)lm(value ~ YearQua, data = df, na.action = na.omit)

mod.data <- cpue.year.gather.nest %>% 
  mutate(model = purrr::map(data, mod_fun))

#3 Extract coefficients
slope_fun <- function(mod) coefficients(mod)[[2]]
ci_lower_fun <- function(mod) confint(mod)[2,1]
ci_upper_fun <- function(mod) confint(mod)[2,2]

summarise.data <- mod.data %>% 
  dplyr::mutate(., slope = map_dbl(model, slope_fun),
            lower_ci = map_dbl(model, ci_lower_fun),
            upper_ci = map_dbl(model, ci_upper_fun))


# plot
# 1 split by Variables
summarise.data.sp <- summarise.data %>% 
  split(summarise.data$Variables) 
   
# 2 Create plot function
plot.fun.slope <- function(.x,.y){
  ggplot(data=.x, aes(x = Species,y = slope))+
    geom_pointrange(aes(ymin = lower_ci, ymax = upper_ci))+
    geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap("Region")+
  ylab(paste0("Slope of temporal change in"," ",.y))+
  theme + ggtitle(.y)+
    coord_flip()
  }

# 3 plot with imap
purrr::imap(summarise.data.sp,plot.fun.slope)


```








# Compute & plot correlogram pairwisew mean overlap_area across time
##--- A bug, can't plot yet.
```{r eval=FALSE}

#--------Compute temporal mean

overlap_mean <- out.all %>% 
  group_by(Region, Species,x,y) %>% 
  #summarise(mean_intersect_area = mean(Number_intersect))
  summarise(mean_overlap = mean(Area_overlap))
  
#--------- Prepare dataframe
#1 select slope column & filter size class
overlap_mean <- overlap_mean %>% 
  select(Region, Species, x, y, mean_overlap) %>%  # Select slope column
  filter(x > 0 & y >1)

#2 Check mean overlap range for each species
overlap_mean %>% 
  group_by(Region, Species) %>% 
  summarise(min = min(mean_overlap),
            max = max(mean_overlap))

#3 transform data from long to wide
overlap.mean.wide <- # long to wide form
  pivot_wider(overlap_mean, 
              names_from = y, 
              values_from = mean_overlap)

#4 replace na to 0
overlap.mean.wide <- overlap.mean.wide %>% 
  replace(is.na(.), 0)   

#----------Draw correlogram
# Split by Species
overlap.mean.wide.pl <- overlap.mean.wide %>% 
  split(list(overlap.mean.wide$Species,
             overlap.mean.wide$Region)) 

# Remove empty lists
overlap.mean.wide.pl <-
  overlap.mean.wide.pl[-c(15,16,17,18)] 
  

# correlogram function
draw.correlogram <-function(.x,.y) {
  dd<-.x[,-c(1,2)]
  dd<-as.matrix(dd)
  rownames(dd)<-c(1,2,3,4,5,6,7,8)
  corrplot(as.matrix(dd),
         method = "circle", 
         is.corr = FALSE,
         type = "upper",
         cl.lim = c(-1,1), # for overlap
         #cl.lim = c(-1,1), # for intersect and union
         col = col2(50),
         title(.y)
         )
}


# draw.correlogram <-function(name) {
#   dd <- overlap.pair.wide.pl %>% 
#     filter(Species == name) 
#   dd<-dd[,-c(1,2)]
#   dd<-as.matrix(dd)
#   rownames(dd)<-c(0,1,2,3,4,5,6,7,8)
#   corrplot(as.matrix(dd),
#          method = "circle", is.corr = FALSE)
# }

# plot with imap
purrr::imap(overlap.mean.wide.pl, draw.correlogram) 
  

```


#-----------------Pairwise---------------------------------
# Compute swc & ns pairewise slope & p-value of overlap ~ time 
```{r eval=F}

#-------- Extract slope from lm (overlap ~ time)

## 1 nest data 
n_overlap <- out.all %>% 
  #ungroup(YearQua) %>% 
  mutate_at('YearQua', as.numeric) %>% 
  group_by(Region,Species, x, y) %>% 
  nest() 

## 2 Apply regression
fun_overlap <-function(df) lm (Area_overlap ~ YearQua, data = df)

m_overlap <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap))


## 3 Extract slope and confidence interval of slope
slope_fun <- function(mod) coefficients(mod)[[2]]
#ci_lower_fun <- function(mod) confint(mod)[2,1]
#ci_upper_fun <- function(mod) confint(mod)[2,2]

m_overlap_summary <- m_overlap %>% 
  transmute(., slope = map_dbl(model, slope_fun)
            #,lower_ci = map_dbl(model, ci_lower_fun),
            #upper_ci = map_dbl(model, ci_upper_fun)
            )

#----------Check model fit

m_overlap_all <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap),
         tidied = purrr::map(model, tidy),
         glanced = purrr::map(model, glance),
         augmented = purrr::map(model, augment))

m_overlap_all %>%
  unnest(tidied)

m_overlap_all %>%
  unnest(augmented)

# p-value, r-square, adjusted r-square
overlap_statistics_table <-
m_overlap_all %>%
  unnest(glanced) %>% 
  select(Region, Species, x,y,r.squared,
         adj.r.squared, p.value)

```

# Test
```{r}

#--------- Prepare dataframe
# select slope column & filter size class
m_overlap_summary <- 
  m_overlap_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope) %>%  
  filter(x > 0 & y >1)

corr.data  <- m_overlap_summary %>% 
  ungroup(Region) %>% 
  select(-Region)

## transform data from long to wide
corr.data  <- # long to wide form
  pivot_wider(corr.data, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
corr.data <- corr.data %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# color limits
m_overlap_summary %>% 
  ungroup() %>% 
  summarise(min = min(slope),
            max = max(slope))

# Data by species
dd.cod <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd.cod<- dd.cod[,-c(1,2)]  
dd.cod <- as.matrix(dd.cod)
rownames(dd.cod) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)
dd.cod

dd.haddock <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd.haddock<- dd.haddock[,-c(1,2)]  
dd.haddock <- as.matrix(dd.haddock)
rownames(dd.haddock) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)
dd.haddock

dd.whiting <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd.whiting  <- dd.whiting [,-c(1,2)]  
dd.whiting<- as.matrix(dd.whiting )
rownames(dd.whiting ) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)
dd.whiting 

# Plot
par(mfrow = c(1,3))
p1 <- corrplot(dd.cod,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("North Sea Atlantic cod overlap slope"),
         mar=c(0,0,2,0)) 

p2 <- corrplot(dd.haddock,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Haddock North Sea overlap slope"),
         mar=c(0,0,2,0)) 


p3 <- corrplot(dd.whiting ,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(30), 
         title = paste0("North Sea Whiting overlap slope"),
         mar=c(0,0,2,0)) 
 

```



# Plot swc & ns pairwise slope of overlap ~ time
```{r eval=F}
plot_overlap_slope <- function(region, region_abb){
  
  #--------- Prepare dataframe
# select slope column & filter size class
m_overlap_summary <- 
  m_overlap_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope)  %>%  
  filter(x > 0 & y >1)

overlap_swc <- m_overlap_summary %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
overlap_swc <- # long to wide form
  pivot_wider(overlap_swc, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
overlap_swc <- overlap_swc %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-overlap_swc %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.03,0.03), # for overlap
         col = col2(50), 
         title = paste0("Atlantic cod",sep = ",", 
                        region_abb, sep = ",", "overlap"),
         mar=c(0,0,2,0)) 

# p2
dd <-overlap_swc %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.03,0.03), # for overlap
         col = col2(50), 
         title = paste0("Haddock",sep = ",", 
                        region_abb, sep = ",", "overlap"),
         mar=c(0,0,2,0)) 

# p3
dd <-overlap_swc %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.03,0.03), # for overlap
         col = col2(50), 
         title = paste0("Whiting",sep = ",", 
                        region_abb, sep = ",", "overlap"),
         mar=c(0,0,2,0)) 
 
# # p4
# dd <-overlap_swc %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.03,0.03), # for overlap
#          col = col2(50), 
#          title = paste0("Saithe",sep = ",", 
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
# 
# # p5
# dd <-overlap_swc %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.03,0.03), # for overlap
#          col = col2(50), 
#          title = paste0("Atlantic mackeral",sep = ",",
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
# 
# 
# # p6
# dd <-overlap_swc %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.03,0.03), # for overlap
#          col = col2(50), 
#          title = paste0("Norway pout",sep = ",", 
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
  
}

# plot_overlap_slope("Scottish West Coast", "swc")
plot_overlap_slope("North Sea","ns")

```


# Plot swc & ns pairewise p-value of overlap ~ time
```{r eval=F}

plot_overlap_pvalue <- function(region, region_abb){
  
#--------- Prepare dataframe
# select p.value column & filter size class

m_overlap_summary_pvalue <- 
  overlap_statistics_table %>% 
  select(Region,Species, x, y, p.value)  %>%  
  filter(x > 0 & y >1)

overlap_swc_pvalue <- m_overlap_summary_pvalue %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
overlap_swc_pvalue <- # long to wide form
  pivot_wider(overlap_swc_pvalue, 
              names_from = y, 
              values_from = p.value)

## replace NA to 0 (NA from another side of wide form)
overlap_swc_pvalue <- overlap_swc_pvalue %>% 
  replace(is.na(.), 0) 

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-overlap_swc_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Atlantic cod",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 



# p2
dd <-overlap_swc_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Haddock",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 


# p3
dd <-overlap_swc_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Whiting",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 



# # p4
# dd <-overlap_swc_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Saithe",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black", sig.level = 0.1) 
# 
# 
# # p5
# dd <-overlap_swc_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Atlantic mackerel",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black", sig.level = 0.1) 
# 
# 
# # p6
# dd <-overlap_swc_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Norway pout",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black", sig.level = 0.1) 

}

# plot_overlap_pvalue("Scottish West Coast", "swc")
plot_overlap_pvalue("North Sea", "ns")

```


# Plot swc & ns pairewise r2 of overlap ~ time
```{r eval=F}

plot_overlap_r2 <- function(region, region_abb){
  
#--------- Prepare dataframe
# select p.value column & filter size class

m_overlap_summary_r2 <- 
  overlap_statistics_table %>% 
  select(Region,Species, x, y, adj.r.squared)  %>%  
  filter(x > 0 & y >1)

overlap_region_r2 <- m_overlap_summary_r2 %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
overlap_region_r2 <- # long to wide form
  pivot_wider(overlap_region_r2, 
              names_from = y, 
              values_from = adj.r.squared)

## replace NA to 0 (NA from another side of wide form)
overlap_region_r2 <- overlap_region_r2 %>% 
  replace(is.na(.), 0) 

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-overlap_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Atlantic cod",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 



# p2
dd <- overlap_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Haddock",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 


# p3
dd <- overlap_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Whiting",sep = ",",
                        region_abb, sep = ",", "overlap",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 



# # p4
# dd <- overlap_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Saithe",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black") 
# 
# 
# # p5
# dd <- overlap_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Atlantic mackerel",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black") 
# 
# 
# # p6
# dd <- overlap_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Norway pout",sep = ",",
#                         region_abb, sep = ",", "overlap",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black") 

}

# plot_overlap_r2("Scottish West Coast", "swc")
plot_overlap_r2("North Sea", "ns")

```




# Compute swc & ns pairewise slope & p-value of centroid distance ~ time 
```{r eval=F}

#-------- Extract slope from lm (distance ~ time)

## 0 Compute absolute distance (lon^2+lat^2)^1/2
centroid_distance <- 
  out_centroid_all %>% mutate (Distance = (((Distance_lon^2)+(Distance_lat^2))^(1/2)))

## 1 nest data 
n_centroid_distance <- centroid_distance %>% 
  ungroup(YearQua) %>% 
  mutate_at('YearQua', as.numeric) %>% 
  group_by(Region,Species, x, y) %>% 
  nest() 


## 2 Apply regression
fun_dis <-function(df) lm (Distance ~ YearQua, data = df)

m_centroid_distance <- n_centroid_distance %>% 
  mutate(model = purrr::map(data, fun_dis))

## 3 Extract slope and confidence interval of slope
slope_fun <- function(mod) coefficients(mod)[[2]]
#ci_lower_fun <- function(mod) confint(mod)[2,1]
#ci_upper_fun <- function(mod) confint(mod)[2,2]

m_centroid_distance_summary <- m_centroid_distance %>% 
  transmute(., slope = map_dbl(model, slope_fun)
            #,lower_ci = map_dbl(model, ci_lower_fun),
            #upper_ci = map_dbl(model, ci_upper_fun)
            )


# Check model fit

m_centroid_distance_all <- n_centroid_distance %>% 
  mutate(model = purrr::map(data, fun_dis),
         tidied = purrr::map(model, tidy),
         glanced = purrr::map(model, glance),
         augmented = purrr::map(model, augment))

m_centroid_distance_all  %>%
  unnest(tidied)

m_centroid_distance_all %>%
  unnest(augmented)

# p-value, r-square, adjusted r-square
m_centroid_distance_statistics_table <-
m_centroid_distance_all  %>%
  unnest(glanced) %>% 
  select(Region, Species, x,y,r.squared,
         adj.r.squared, p.value)


#-------Plot all pairwise area~year to see model fit
n_centroid_distance

plot_distance <- function(df) plot(Distance ~ YearQua, data = df)

n_centroid_distance %>%
  mutate(plot = map(data, plot_distance))


```



# Plot swc & ns pairwise slope of centroid distance ~ time
```{r eval=F}

# min and max of slope
m_centroid_distance_summary %>% 
  group_by(Species, Region) %>% 
  summarise(min = min(slope, na.rm = T),
            max = max(slope, na.rm = T))


# plot
plot_distance_slope <- function(region, region_abb){
  
  #--------- Prepare dataframe
# select slope column & filter size class
m_centroid_distance_summary <- 
  m_centroid_distance_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope)  %>%  
  filter(x > 0 & y >1)

distance_region <- m_centroid_distance_summary %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
distance_region <- # long to wide form
  pivot_wider(distance_region, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
distance_region <- distance_region %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-distance_region%>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.3,0.3), 
         col = col2(50), 
         title = paste0("Atlantic cod",sep = ",", 
                        region_abb, sep = ",", "centroid distance"),
         mar=c(0,0,2,0)) 

# p2
dd <-distance_region %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.3,0.3), 
         col = col2(50), 
         title = paste0("Haddock",sep = ",", 
                        region_abb, sep = ",", "centroid distance"),
         mar=c(0,0,2,0)) 

# p3
dd <-distance_region %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "color", is.corr = FALSE,
         type = "upper",
         cl.lim = c(-0.3,0.3), 
         col = col2(50), 
         title = paste0("Whiting",sep = ",", 
                        region_abb, sep = ",", "centroid distance"),
         mar=c(0,0,2,0)) 

# # p4
# dd <-distance_region %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.3,0.3), 
#          col = col2(50), 
#          title = paste0("Saithe",sep = ",", 
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
# 
# # p5
# dd <-distance_region %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.3,0.3), 
#          col = col2(50), 
#          title = paste0("Atlantic mackeral",sep = ",",
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
# 
# 
# # p6
# dd <-distance_region %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "color", is.corr = FALSE,
#          type = "upper",
#          cl.lim = c(-0.3,0.3), 
#          col = col2(50), 
#          title = paste0("Norway pout",sep = ",", 
#                         region_abb, sep = ",", "overlap"),
#          mar=c(0,0,2,0)) 
#   
}

# plot_distance_slope("Scottish West Coast", "swc")
plot_distance_slope("North Sea","ns")

```


# Plot swc & ns pairewise p-value of centroid distance ~ time
```{r eval=F}


plot_distance_pvalue <- function(region, region_abb){
  
#--------- Prepare dataframe
# select p.value / adj.r.squared column & filter size class

m_centroid_distance_pvalue <- 
  m_centroid_distance_statistics_table %>% 
  select(Region,Species, x, y, p.value)  %>%  
  filter(x > 0 & y >1)

distance_region_pvalue <- m_centroid_distance_pvalue %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
distance_region_pvalue <- # long to wide form
  pivot_wider(distance_region_pvalue, 
              names_from = y, 
              values_from = p.value)

## replace NA to 0 (NA from another side of wide form)
distance_region_pvalue <- distance_region_pvalue %>% 
  replace(is.na(.), 0) 

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-distance_region_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Atlantic cod",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 



# p2
dd <-distance_region_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Haddock",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 


# p3
dd <-distance_region_pvalue %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Whiting",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "p-value"),
         mar=c(0,0,2,0),
         addCoef.col = "black", col = "black", 
         p.mat = dd,
         tl.col = "black", sig.level = 0.1) 



# # p4
# dd <-distance_region_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Saithe",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black", sig.level = 0.1) 
# 
# 
# # p5
# dd <-distance_region_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Atlantic mackerel",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black", sig.level = 0.1) 
# 
# 
# # p6
# dd <-distance_region_pvalue %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Norway pout",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "p-value"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black", col = "black", 
#          p.mat = dd,
#          tl.col = "black" #, sig.level = 0.1
#          ) 

}

# plot_distance_pvalue("Scottish West Coast", "swc")
plot_distance_pvalue("North Sea", "ns")

```


# Plot swc & ns pairewise r2 of centroid distance ~ time
```{r eval=F}


plot_distance_r2 <- function(region, region_abb){
  
#--------- Prepare dataframe
# select  adj.r.squared column & filter size class

m_centroid_distance_r2 <- 
  m_centroid_distance_statistics_table %>% 
  select(Region,Species, x, y, adj.r.squared)  %>%  
  filter(x > 0 & y >1)

distance_region_r2 <- m_centroid_distance_r2 %>% 
  filter(Region == region) %>% 
  ungroup() %>% select(-Region)

## transform data from long to wide
distance_region_r2 <- # long to wide form
  pivot_wider(distance_region_r2, 
              names_from = y, 
              values_from = adj.r.squared)

## replace NA to 0 (NA from another side of wide form)
distance_region_r2 <- distance_region_r2 %>% 
  replace(is.na(.), 0) 

# to create 2x3 matrix for sub-plots

par(mfrow = c(2,3))

# p1
dd <-distance_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p1 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Atlantic cod",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 



# p2
dd <-distance_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p2 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Haddock",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 


# p3
dd <-distance_region_r2 %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd<- dd[,-c(1,2)]  
dd<- as.matrix(dd)
rownames(dd) <- c(1,2,3,4,5,6,7,8)
dd

p3 <- corrplot(dd,
         method = "number", is.corr = FALSE,
         type = "upper",
         title = paste0("Whiting",sep = ",",
                        region_abb, sep = ",", "centroid distance",
                         sep = "", "adj R2"),
         mar=c(0,0,2,0),
         addCoef.col = "black") 



# # p4
# dd <-distance_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Saithe")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p4 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Saithe",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black") 
# 
# 
# # p5
# dd <-distance_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Atlantic mackerel")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p5 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Atlantic mackerel",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black") 
# 
# 
# # p6
# dd <-distance_region_r2 %>% 
#   ungroup() %>% 
#   filter (Species == "Norway pout")
# dd<- dd[,-c(1,2)]  
# dd<- as.matrix(dd)
# rownames(dd) <- c(1,2,3,4,5,6,7,8)
# dd
# 
# p6 <- corrplot(dd,
#          method = "number", is.corr = FALSE,
#          type = "upper",
#          title = paste0("Norway pout",sep = ",",
#                         region_abb, sep = ",", "centroid distance",
#                          sep = "", "adj R2"),
#          mar=c(0,0,2,0),
#          addCoef.col = "black"
#          ) 

}

# plot_distance_r2("Scottish West Coast", "swc")
plot_distance_r2("North Sea", "ns")

```



#--------------------- Relationships--------------------------



# Mean_Prop_Subarea ~ CPUE_year
```{r}

# 1 filter
cpue.year.filter <- cpue.year  %>% 
  filter(log(CPUE_Year) > 6) %>% 
  filter(Mean_Prop_SubArea < 0.7)

# 3.1 Plot by species
dot1 <- cpue.year.filter.gather %>% 
  filter(Species=="Haddock" & Variables =="Paired_habitat_overlap") %>%
  mutate(LineGroup = 1)

cpue.year.filter.gather2 <- left_join(cpue.year.filter.gather,dot1)  

cpue.year.filter.gather2<- cpue.year.filter.gather2 %>% 
  replace_na(list(LineGroup = 0)) 

ggplot(cpue.year.filter,
       aes(x = log(CPUE_Year), 
                     y= Mean_paired_lat_distance))+
    geom_point(aes(colour = Species), size = 1)+
  geom_smooth(method = 'lm',aes(colour = Species))+
  #geom_smooth(method='lm', colour = "black",formula= y~x, aes(linetype=as.factor(LineGroup)))+
 facet_wrap(vars(Species), scales = "free")+theme 

# 3.3 regression 
cpue.year.filter <-
  cpue.year.filter %>% 
  group_by(Species) %>% 
  nest()

regression_fun <- function(df) lm(Mean_paired_lon_distance ~ Mean_Prop_SubArea,data = df)

cpue.year.filter.model <- cpue.year.filter %>% 
  mutate(model = purrr::map(data, regression_fun),
         tidied = purrr::map(model, tidy),
         glanced = purrr::map(model, glance),
         augmented = purrr::map(model, augment))

# This shows r2 and p value
cpue.year.filter.model %>% 
  unnest(glanced) # note species order is changed.

```


# overlap / Prop_hab/ distance ~ CPUE
```{r}

plot(log(cpue.year$CPUE_Year),cpue.year$Paired_habitat_overlap)
plot(log(cpue.year$CPUE_Year),cpue.year$Mean_Prop_SubArea)
plot(log(cpue.year$CPUE_Year),cpue.year$Mean_paired_lon_distance)
plot(log(cpue.year$CPUE_Year),cpue.year$Mean_paired_lat_distance)# It seems there are two groups. Plot linear regression line for each species to see if there is really a positive relationship.

plot(cpue.year$Mean_Prop_SubArea,cpue.year$Mean_paired_lat_distance)
plot(cpue.year$Mean_Prop_SubArea,cpue.year$Mean_paired_lon_distance)

cpue.year.filter <-
  cpue.year %>% 
  filter(log(CPUE_Year) >10)

ggplot(cpue.year.filter,
       aes(x = log(CPUE_Year), 
                     y= Mean_paired_lat_distance))+
    geom_point(aes(colour = Species), size = 1)+
  geom_smooth(method = 'lm',aes(colour = Species))+
  #geom_smooth(method='lm', colour = "black",formula= y~x, aes(linetype=as.factor(LineGroup)))+
 facet_wrap(vars(Species), scales = "free")+theme 

```


# Relationship overlap & centroid
To continue: better gather into x_variable and y_variable, then plot and model. It is clearer and more efficient.
```{r}

# Plot relationship between habitat overlap and centroid distance
plot(cpue.year$Mean_paired_lon_distance,
     cpue.year$Paired_habitat_overlap)

plot(cpue.year$Mean_paired_lat_distance,
     cpue.year$Paired_habitat_overlap)

plot(cpue.year$Mean_paired_lon_distance,
     cpue.year$Paired_habitat_overlap_deno)

plot(cpue.year$Mean_paired_lat_distance,
     cpue.year$Paired_habitat_overlap_deno)

# Graphs
ggplot(data=cpue.year, aes(x=Mean_paired_lon_distance,
                           y=Paired_habitat_overlap))+
    geom_point()+
      facet_wrap ('Species',scales = "free")+
    geom_smooth(method='lm', formula= y~x)+
    theme 

ggplot(data=cpue.year, aes(x=Mean_paired_lat_distance,
                           y=Paired_habitat_overlap_deno))+
    geom_point()+
      facet_wrap ('Species', scales = "free")+
    geom_smooth(method='lm', formula= y~x)+
    theme 

ggplot(data=cpue.year, aes(x=Mean_paired_lon_distance,
                           y=Paired_habitat_overlap))+
    geom_point()+
      facet_wrap ('Species', scales = "free")+
    geom_smooth(method='lm', formula= y~x)+
    theme 

ggplot(data=cpue.year, aes(x=Mean_paired_lat_distance,
                           y=Paired_habitat_overlap_deno))+
    geom_point()+
      facet_wrap ('Species', scales = "free")+
    geom_smooth(method='lm', formula= y~x)+
    theme 


# Models
cpue.year.cod <- cpue.year %>% 
  filter(Species == "Atlantic cod")

cpue.year.haddock <- cpue.year %>% 
  filter(Species == "Haddock")

cpue.year.whiting <- cpue.year %>% 
  filter(Species == "Whiting")

summary(lm(Paired_habitat_overlap~Mean_paired_lon_distance, 
   data = cpue.year.cod))

summary(lm(Paired_habitat_overlap~Mean_paired_lat_distance, 
   data = cpue.year.cod))

summary(lm(Paired_habitat_overlap_deno~Mean_paired_lon_distance, 
   data = cpue.year.cod))

summary(lm(Paired_habitat_overlap_deno~Mean_paired_lat_distance, 
   data = cpue.year.cod))



```




# Habitat area ~ CPUE (length specific)
```{r}
# prop_hab ~ prop_abun
cpue.length.year.split <- cpue.length.year %>%
  ungroup("Length") %>% 
    mutate_at('Length', as.character) %>%
    mutate_at('YearQua', as.numeric) %>%
    filter(Length %in% c(1,2,3,4,5,6,7,8)) 

cpue.length.year.split <- cpue.length.year.split %>%
  split(cpue.length.year.split$Species)
  
 plot.fun.hab.cpue <-function(.x, .y){
   ggplot(data = .x,
          aes(y=Num_SubArea_Length,x=log(CPUE_Length_Year)))+
    scale_colour_viridis_d()+
    geom_smooth(aes(color = Length), method = "lm", formula = 'y~x')+
    geom_point(aes(color = Length))+ theme+
  ggtitle(.y)+ylab("prop_habitat") +xlab ("prop_abundance")
 } 
    
imap(cpue.length.year.split, plot.fun.hab.cpue)

cpue.length.year
```


# Habitat overlap/distance ~ size diversity/mean age

```{r}

cpue.year %>% 
  ggplot(aes(x = Regional_Shannon,
             y = Paired_habitat_overlap))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Yearly mean grid-scale Shannon index from raw length ")+ ylab("Yearly mean paired overlap area")+
  ggtitle("Habitat overlap ~ size diversity")+ 
  theme

cpue.year %>% 
  ggplot(aes(x = Regional_Shannon,
             y = Paired_habitat_overlap_deno))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='lm', formula= y~x)+
  xlab("Yearly mean grid-scale Shannon index from raw length ")+ ylab("Yearly mean paired overlap area")+
  ggtitle("Habitat overlap ~ size diversity")+ 
  theme


cpue.year %>% 
  ggplot(aes(x = Regional_Shannon,
             y = Paired_habitat_overlap_deno))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Yearly mean grid-scale Shannon index from raw length ")+ ylab("Yearly mean paired overlap area")+
  ggtitle("Habitat overlap ~ size diversity")+ 
  theme


cpue.year %>% 
  ggplot(aes(x = Regional_mean_size,
             y = Paired_habitat_overlap_deno))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Yearly mean grid-scale Shannon index from raw length ")+ ylab("Yearly mean paired overlap area")+
  ggtitle("Habitat overlap ~ size diversity")+ 
  theme

cpue.year %>% 
  ggplot(aes(x = Regional_size_richness,
             y = Mean_paired_lat_distance))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Yearly mean grid-scale Shannon index from raw length ")+ 
  ggtitle("Habitat overlap ~ size diversity")+ 
  theme

```



#------------Fishing & bottomT ----------------

# Plot Fishing & bottomT ~ year
```{r}
# TSB ~ Year
cpue.year %>% 
  ggplot(aes(y = TSB_Tonnes / 1000000,
             x = Year,
             color = Species))+
           geom_point()+
  geom_line()+
  geom_smooth(method='lm', formula= y~x)+
  xlab("Year")+ 
  ylab("Total stock biomass (million)")+ 
  theme

# Fishing mortality ~ Year
cpue.year %>% 
  ggplot(aes(y = Fishing_Mortality,
             x = Year,
             color = Species))+
           geom_point()+
  geom_line()+
  xlab("Year")+ 
  ylab("Fishing mortality")+ 
  theme

#bottomT~ Year
cpue.year %>% 
  ggplot(aes(y = MeanBT,
             x = Year))+
           geom_point()+
  geom_line()+
  geom_smooth(method='lm', formula= y~x)+
  xlab("Year")+ 
  ylab("Bottom Temperature")+ 
  theme

```


# Fishing mortality & TSB
```{r}

# FishingM ~ Year
cpue.year %>% 
  ggplot(aes(y = Fishing_Mortality,
             x = Year))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Year")+ 
  ggtitle("")+ 
  theme


# Mean age ~ Year
cpue.year %>% 
  ggplot(aes(y = Mean_age_10Length,
             x = Year))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='loess', formula= y~x)+
  xlab("Year")+ 
  ggtitle("")+ 
  theme

# Mean age ~ FishingM
cpue.year %>% 
  ggplot(aes(y = Mean_age_10Length,
             x = Fishing_Mortality))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='lm', formula= y~x)+
  xlab("")+ 
  ggtitle("")+ 
  theme

m1 <- lm(cpue.year$Mean_age_10Length ~ cpue.year$Fishing_Mortality)
anova(m1)
summary(m1)

# habitat overlap~ fishing M/TSB
cpue.year %>% 
  ggplot(aes(y = Paired_habitat_overlap,
             x = Fishing_Mortality))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='lm', formula= y~x)+
  ggtitle("")+ 
  theme

cpue.year %>% 
  ggplot(aes(y = Paired_habitat_overlap,
             x = TSB_Tonnes))+
           geom_point()+
  facet_wrap(~Species, scales = "free")+
  geom_smooth(method='lm', formula= y~x)+
  ggtitle("")+ 
  theme

```




# Model habitat area & COG~ temp*length + TSB*length
Used Temperature value from MeanBT (Wang2020) 
Next: trim to parsimonious model

```{r}
# These model examine whether effects of temperature & fishing on distribution shift depends on length (interactive effects of temperature and length)

# Function to model all species and lon/lat
mod_lon <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species) %>% 
  mutate_at("Length", as.factor) 
  
  model <- lmer(Centroid_lon ~
             Length * MeanBT_scale+
             Length * TSB_Tonnes_scale
           + (1|Year), 
           data = cog.species)
  #anova(model)
  model
}

mod_lat <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species) %>% 
  mutate_at("Length", as.factor) 
  
  model <- lmer(Centroid_lat ~
             Length * MeanBT_scale+
             Length * TSB_Tonnes_scale
           + (1|Year), 
           data = cog.species)
  anova(model)
}

mod_habitat_prop <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species) %>% 
  mutate_at("Length", as.factor) %>% 
    mutate_at("Prop_SubArea_Length", as.numeric)
  
  model <- lmer(Prop_SubArea_Length ~
             Length * MeanBT_scale+
             Length * TSB_Tonnes_scale
           + (1|Year), 
           data = cog.species)
  anova(model)
}

mod_habitat_Num <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species) %>% 
  mutate_at("Length", as.factor) %>% 
    mutate_at("Num_SubArea_Length", as.numeric)
  
  model <- lmer(Num_SubArea_Length ~
             Length * MeanBT_scale+
             Length * TSB_Tonnes_scale
           + (1|Year), 
           data = cog.species)
  anova(model)
}

mod_lon("Atlantic cod")
mod_lat("Atlantic cod")
mod_habitat_prop("Atlantic cod")
mod_habitat_Num("Atlantic cod")

mod_lon("Haddock")
mod_lat("Haddock")
mod_habitat_prop("Haddock")
mod_habitat_Num("Haddock")

mod_lon("Whiting")
mod_lat("Whiting")
mod_habitat_prop("Whiting")
mod_habitat_Num("Whiting")


```

# Parsimonious model of previous chunk
```{r}

#-------------- 1. Cod subset 
cpue.length.year.cod <- cpue.length.year %>% 
  mutate_at("Length", as.factor) %>% 
  filter(Species == "Atlantic cod")
  
# lon
m1<-lmer(Centroid_lon ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.cod)

anova(m1)
m2<- update(m1,~.- TSB_Tonnes_scale)
anova(m2)
m3<-update(m2,~.- MeanBT_scale)
anova(m3)
m4<-update(m3,~.- Length:MeanBT_scale)
anova(m4)
summary(m4)
(summary(m4))["coefficients"][[1]]


# lat
m1<-lmer(Centroid_lat ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.cod)

anova(m1)
m2<- update(m1,~.-MeanBT_scale)
anova(m2)
m3<-update(m2,~.-Length:MeanBT_scale)
anova(m3)
anova(m2,m3)
summary(m3)

# Prop_subarea
m1<-lmer( Prop_SubArea_Length ~ Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.cod)

anova(m1)
m2<- update(m1,~.- Length:MeanBT_scale)
anova(m2)
m3<-update(m2,~.- MeanBT_scale)
anova(m3)
summary(m3)



#-------- 2. Haddock subset 
cpue.length.year.haddock <- cpue.length.year %>% 
  mutate_at("Length", as.factor) %>% 
  filter(Species == "Haddock")
  
# lon
m1<-lmer(Centroid_lon ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.haddock)

anova(m1)
m2<- update(m1,~.- TSB_Tonnes_scale)
anova(m2)
m3<-update(m2,~.- Length:TSB_Tonnes_scale)
anova(m3)
m4<-update(m3,~.- Length:MeanBT_scale)
anova(m4)
summary(m4)
(summary(m4))["coefficients"][[1]]


# lat
m1<-lmer(Centroid_lat ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.haddock)

anova(m1)
m2<- update(m1,~.- TSB_Tonnes_scale)
anova(m2)
m3<-update(m2,~.- Length:TSB_Tonnes_scale)
anova(m3)
AIC(m2)
AIC(m3)
summary(m3)
m4<-update(m3,~.- Length:MeanBT_scale)
summary(m4)
AIC(m4)

# Prop_subarea
m1<-lmer( Prop_SubArea_Length ~ Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.haddock)

anova(m1)
m2<- update(m1,~.- Length:MeanBT_scale)
anova(m2)
m3<-update(m2,~.- MeanBT_scale)
anova(m3)
summary(m3)






#-------- 3. Whiting subset 
cpue.length.year.whiting <- cpue.length.year %>% 
  mutate_at("Length", as.factor) %>% 
  filter(Species == "Whiting")
  
# lon
m1<-lmer(Centroid_lon ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.whiting)

anova(m1)
m2<- update(m1,~.- MeanBT_scale)
anova(m2)
m3<-update(m2,~.- TSB_Tonnes_scale)
anova(m3)
m4<-update(m3,~.- Length:TSB_Tonnes_scale)
anova(m4)
summary(m4)



# lat
m1<-lmer(Centroid_lat ~Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.whiting)

anova(m1)
m2<- update(m1,~.- Length:MeanBT_scale )
anova(m2)
m3<-update(m2,~.- MeanBT_scale )
anova(m3)
m4<-update(m3,~.- TSB_Tonnes_scale)
anova(m4)
summary(m4)


# Prop_subarea
m1<-lmer( Prop_SubArea_Length ~ Length * MeanBT_scale+
       Length * TSB_Tonnes_scale
           + (1|Year), data = cpue.length.year.whiting)

anova(m1)
m2<- update(m1,~.- MeanBT_scale)
anova(m2)
m3<-update(m2,~.- Length:MeanBT_scale )
anova(m3)
summary(m3)

```


# Model overlap & distance & prop_habitat ~ Fishing+temp 
## Length or pair_id as fixed
```{r}
# Lon distance Wang 2020
mod_lon_distance_Wang <- function(species){
  cog.species <- cpue.pair %>% 
  filter(Species == species) 
  
  model <- lmer(Distance_lon ~
             Pair_id * MeanBT_scale+
             Pair_id * TSB_Tonnes_scale+
               (1|Year),
           data = cog.species)
  
  anova(model)
}



# Lat distance Wang2020
mod_lat_distance_Wang <- function(species){
  cog.species <- cpue.pair %>% 
  filter(Species == species)
  
  model <- lmer(Distance_lat ~
             Pair_id * MeanBT_scale+
             Pair_id * TSB_Tonnes_scale+
               (1|Year),
           data = cog.species)
  
  anova(model)
}

# Lat distance Tu 2018
mod_lat_distance_Tu <- function(species){
  cog.species <- cpue.pair %>% 
  filter(Species == species)
  
  model <- lmer(Distance_lat ~
             Pair_id * MeanBT_Tu2018_scale+
             Pair_id * TSB_Tonnes_scale+
               (1|Year),
           data = cog.species)
  
  anova(model)
}

# Prop_habitat Wang 2020
mod_prop_subarea_Wang <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species)
  
  model <- lmer(Prop_SubArea_Length ~
             Length * MeanBT_scale+
             Length * TSB_Tonnes_scale+
               (1|YearQua),
           data = cog.species)
  
  anova(model)
}

# Prop_habitat Tu 2018
mod_prop_subarea_Tu <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species)
  
  model <- lmer(Prop_SubArea_Length ~
             Length * MeanBT_Tu2018_scale+
             Length * TSB_Tonnes_scale+
               (1|YearQua),
           data = cog.species)
  
  anova(model)
}

lon1.w <- mod_lon_distance_Wang("Atlantic cod")
lon2.w <- mod_lon_distance_Wang("Haddock")
lon3.w <- mod_lon_distance_Wang("Whiting")

lat1.w <- mod_lat_distance_Wang("Atlantic cod")
lat2.w <- mod_lat_distance_Wang("Haddock")
lat3.w <- mod_lat_distance_Wang("Whiting")

pro1.w <- mod_prop_subarea_Wang("Atlantic cod")
pro2.w <- mod_prop_subarea_Wang("Haddock")
pro3.w <- mod_prop_subarea_Wang("Whiting")

lon1.w
lon2.w
lon3.w
lat1.w
lat2.w
lat3.w
pro1.w
pro2.w
pro3.w

```


# Parsimonious model of previous chunk
```{r eval=FALSE}

m.lon.cod <-mod_lon_distance ("Atlantic cod")
anova(m.lon.cod)
m.lon.cod.1 <- update (m.lon.cod,~.- Pair_id:MeanBT_scale )
anova(m.lon.cod.1)
anova(m.lon.cod, m.lon.cod.3)
m.lon.cod.2 <- update (m.lon.cod.1,~.- TSB_Tonnes_scale)
anova(m.lon.cod.2)
m.lon.cod.3 <- update (m.lon.cod.2,~.- MeanBT_scale)
anova(m.lon.cod.3) # final model
AIC(m.lon.cod, m.lon.cod.1, m.lon.cod.2, m.lon.cod.3)
s1 <- (summary(m.lon.cod.3))["coefficients"][[1]]
```


# Model overlap & distance & prop_habitat ~ Fishing+temp 
## Length or pair_id as random
```{r}
mod_lon_distance_r <- function(species){
  cog.species <- cpue.pair %>% 
  filter(Species == species) 
  
  model <- lmer(Distance_lon ~
             MeanBT_scale+
             TSB_Tonnes_scale+
               (1|Year)+ (1|Pair_id),
           data = cog.species)
  
  summary(model)
}

mod_lat_distance_r <- function(species){
  cog.species <- cpue.pair %>% 
  filter(Species == species) 
  
  model <- lmer(Distance_lat ~
            MeanBT_scale+
             TSB_Tonnes_scale+
               (1|Year) + (1|Pair_id),
           data = cog.species)
  
  summary(model)
}

mod_prop_subarea_r <- function(species){
  cog.species <- cpue.length.year %>% 
  filter(Species == species)
  
  model <- lmer(Prop_SubArea_Length ~
              MeanBT_scale+
             TSB_Tonnes_scale+
               (1|YearQua) + (1|Length),
           data = cog.species)
  
  summary(model)
}


mod_lon_distance_r("Atlantic cod")
mod_lon_distance_r("Haddock")
mod_lon_distance_r("Whiting")

mod_lat_distance_r("Atlantic cod")
mod_lat_distance_r("Haddock")
mod_lat_distance_r("Whiting")

mod_prop_subarea_r("Atlantic cod")
mod_prop_subarea_r("Haddock")
mod_prop_subarea_r("Whiting")


```


