---
title: "ns_3Species"
output: html_document
editor_options: 
  chunk_output_type: inline
---

#-------------- data preparation-----------
# setup
```{r}

library(devtools)
library(ggplot2)
library(tidyverse)
library(moments)
library(mapplots)
library(knitr)
library(gridExtra)
library(rfishbase)
library(broom)
library(purrr)
library(corrplot)
library(openxlsx)
library(dplyr)
library(RColorBrewer)
library(lme4)
library(lmerTest)
library(nlme)
library(astsa)
library(car)
library(MuMIn)
library(leaps)
library(viridis)
library(DHARMa)
library(sjPlot)
library(maps)


```


# Read data 
Here data from both the North Sea and Scottish West Coast were included. For the main text of this manuscript, we included only 3 species in the North Sea.
```{r}

# Read data: SWC_stn
swc.stn<-read.csv("a0_ices_raw_data/SWC_stn.csv")
swc.stn$Region <-"Scottish West Coast"

# Read data: NS_stn_1965_2000, NS_stn_2001_2020
ns.stn.1<-read.csv("a0_ices_raw_data/NS_stn_1965_2000.csv")
ns.stn.2<-read.csv("a0_ices_raw_data/NS_stn_2001_2020.csv")
ns.stn.1$Region <- "North Sea"
ns.stn.2$Region <- "North Sea"

ns.stn <- bind_rows(ns.stn.1, ns.stn.2)

# dd.stn has all data
dd.stn <-bind_rows(swc.stn,ns.stn.1,ns.stn.2)

dd.stn %>% 
  group_by(Region,Species) %>% 
  tally()


```


# Clean data and rename 
```{r}

#---------Remove unnessary columns----------------------------
dd.stn <- dd.stn %>%
  select(-c(Survey,Area,AphiaID,DateofCalculation))


#---------Remove LngtClass = 0 --------------------------------
# Because CPUE of LngtClass = 0 is always 0
dd.stn <- dd.stn %>%
  filter(LngtClass > 0) 

# Check max and min length 
dd.stn %>%
  group_by(Species, Region) %>%
  summarise(max_length = max(LngtClass),
            min_length = min(LngtClass))

#--------Remove subareas with 0 CPUE----------------------
# Updated 200701 to remove raw CPUE_number_per_hour with 0
# So to remove all subarea with 0 CPUE for each length and time point

dd.stn <- dd.stn %>%
  filter(CPUE_number_per_hour > 0) 

#-----------Keep all Quarters at this moment.
dd.stn %>%
  group_by(Region) %>% 
  count(Year,Quarter)


#-------------rename species to common names----------------
dd.stn <- dd.stn %>% rename(Scientific_Name = Species )

dd.stn <- dd.stn %>% 
    mutate(Species = case_when
           ( Scientific_Name == "Clupea harengus" ~ 'Atlantic herring',
             Scientific_Name == "Gadus morhua" ~ 'Atlantic cod',
             Scientific_Name == "Melanogrammus aeglefinus" ~ 'Haddock',
             Scientific_Name == "Merlangius merlangus" ~ 'Whiting',
             Scientific_Name == "Pleuronectes platessa" ~ 'Plaice',
             Scientific_Name == "Pollachius virens" ~ 'Saithe',
             Scientific_Name == "Scomber scombrus" ~ 'Atlantic mackerel',
             Scientific_Name == "Sprattus sprattus" ~ 'Sprat',
             Scientific_Name == "Trisopterus esmarkii" ~ 'Norway pout'
             ))


dd.stn$Species <- fct_relevel(dd.stn$Species, 
                       c('Atlantic cod', 'Haddock', 'Whiting',
                         'Saithe','Atlantic mackerel','Norway pout',
                         'Atlantic herring', 'Plaice', 'Sprat'))    

#--------------Add YearQua-------------------------
dd.stn <- dd.stn %>%
  mutate(YearQua=paste(Year,Quarter,sep=".")) 

```  
  
 
# Remove individuals with extreme lengths 
```{r}

# create q.limit for plotting size distribution as Fig S1. 

q.limit <- dd.stn %>% 
  group_by(Species) %>% 
  summarise(Lower_limit = min(LngtClass) + 
           (0.05 * (max(LngtClass)-min(LngtClass))),
         Upper_limit= min(LngtClass + 
            (0.80 * (max(LngtClass)-min(LngtClass)))))  

# create dd.stn.before.cut

dd.stn.before.cut <- dd.stn

# Remove individuals below 5% and above 80% quantile of length range

dd.stn <- dd.stn %>% 
  group_by(Species, Region) %>% 
  mutate(Lower_limit = min(LngtClass) + 
           (0.05 * (max(LngtClass)-min(LngtClass))),
         Upper_limit= min(LngtClass + 
            (0.80 * (max(LngtClass)-min(LngtClass))))) %>% 
  filter(LngtClass > Lower_limit & LngtClass < Upper_limit) 
 
```


# Filter to 3 species of the North Sea  
```{r}

dd.stn <- dd.stn %>%
  filter(Region == "North Sea" & Species %in% c("Atlantic cod","Haddock", "Whiting"))

```
  

# Select between year 1977-2019, Q1
```{r}
dd.stn <- dd.stn %>% 
  filter(Year >=1977 & Year < 2020)

dd.stn <- dd.stn %>% 
  filter(Quarter == "1")

dd.stn %>% 
  group_by(Year,Quarter) %>% 
  tally()

```
  
  
# filter dd.stn.before.cut to plot size distribution
```{r}

dd.stn.before.cut <- dd.stn.before.cut %>% 
   filter(Year >=1977 & Year < 2020) %>% 
   filter(Quarter == "1")
  
```


# set up theme for ggplots 
```{r}
theme <- 
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"),
    #axis.text.x=element_blank(),
    #axis.ticks.x=element_blank(),
    legend.position="none")

```



#------ Calculate spatial indicators ----------

# Create cpue.lngt.subarea.yearqua

```{r}

# Create cpue.lngt.subarea.yearqua

cpue.lngt.subarea.yearqua <-
  dd.stn %>%
  group_by(Region,Species,YearQua,SubArea,LngtClass) %>%
  summarise(CPUE_Lngt_SubArea_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>%
  group_by(Region,Species, YearQua, SubArea) %>% 
  mutate(CPUE_All_Lngt_SubArea_Yearqua = sum(CPUE_Lngt_SubArea_YearQua))

```


# Create cpue.lngt.yearqua

```{r }
cpue.lngt.yearqua <-
  dd.stn %>%
  group_by(Region,Species,YearQua,LngtClass) %>%
  summarise(CPUE_Lngt_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>% 
  # Add CPUE_All_Lngt_Yearqua 
  group_by(Region, Species, YearQua) %>% 
  mutate(CPUE_All_Lngt_Yearqua = sum(CPUE_Lngt_YearQua)) %>% 
  mutate(Denstiy_CPUE_Lngt_Yearqua = 
           CPUE_Lngt_YearQua/CPUE_All_Lngt_Yearqua)

```


# Create cpue.lngt.yearqua for plotting size distribution

```{r}

cpue.lngt.yearqua.before.cut <-
  dd.stn.before.cut %>%
  group_by(Region,Species,YearQua,LngtClass) %>%
  summarise(CPUE_Lngt_YearQua = sum(CPUE_number_per_hour),
            .groups = "drop") %>% 
  # Add CPUE_All_Lngt_Yearqua 
  group_by(Region, Species, YearQua) %>% 
  mutate(CPUE_All_Lngt_Yearqua = sum(CPUE_Lngt_YearQua)) %>% 
  mutate(Denstiy_CPUE_Lngt_Yearqua = 
           CPUE_Lngt_YearQua/CPUE_All_Lngt_Yearqua)


```


# compare cpue.lngt.yearqua.before.cut & cpue.lngt.yearqua
```{r}

dd.cut <- cpue.lngt.yearqua.before.cut %>% group_by(Species) %>% 
  summarise(cpue_sum = sum(CPUE_Lngt_YearQua))
  
dd.all <- cpue.lngt.yearqua %>% group_by(Species) %>% 
  summarise(cpue_sum = sum(CPUE_Lngt_YearQua))
  
dd.join <- left_join(dd.all, dd.cut, by = "Species")

dd.join %>% mutate(
  ratio = (cpue_sum.y - cpue_sum.x)/cpue_sum.y)

```


# Create cpue.length.subarea.yearqua & cpue.subarea.yearqua
```{r }

cpue.length.subarea.yearqua <-dd.stn %>% 
  group_by(Region, Species) %>%
  # (Original length class - min class)/ (length range/10)
  mutate(Length=(LngtClass-min(LngtClass)) %/% ((max(LngtClass)-min(LngtClass))/20)) %>%
  filter (Length < 20) %>%
  # Add cpue of all LngtClasses that belong to each Length
  group_by(Region,Species,YearQua,SubArea,Length) %>% 
  summarize(CPUE_Length_Subarea_Yearqua=sum(CPUE_number_per_hour))  

cpue.subarea.yearqua <-cpue.length.subarea.yearqua %>%
  group_by(Region, Species, YearQua, SubArea) %>%
  summarize(CPUE_All_Length_Subarea_Yearqua = sum(CPUE_Length_Subarea_Yearqua))


# Add CPUE_All_Length_Subarea_Yearqua to tibble cpue.length.subarea.yearqua
cpue.length.subarea.yearqua<-cpue.length.subarea.yearqua %>%
  left_join(cpue.subarea.yearqua,by=c("Region","Species", "YearQua", "SubArea"))

# Check how many ind in each Length
cpue.length.subarea.yearqua %>% 
  group_by(Region,Species, Length) %>% 
  tally()

```


# summary of body size bin
```{r}

dd.stn %>% 
  group_by(Region, Species) %>%
  # (Original length class - min class)/ (length range/10)
  summarise(range = max(LngtClass)-min(LngtClass),
            interval= range/20)

```



# Create cpue.length.year & cpue.year
```{r }

cpue.length.year <- cpue.length.subarea.yearqua %>%
  group_by(Region, Species,YearQua,Length) %>%
  summarize(CPUE_Length_Year=sum(CPUE_Length_Subarea_Yearqua)) 

# Sum of all CPUE per species (sum all length) per YearQua
cpue.year <- cpue.length.year %>%
  group_by(Region, YearQua, Species) %>%
  summarize(CPUE_Year = sum(CPUE_Length_Year)) 


#--------------------------------------------
# Compute Prop_CPUE_Length_Year

# 1 Add CPUE_Year to tibble cpue.length.year
cpue.length.year<-cpue.length.year %>%
  left_join(cpue.year,by=c("Region","YearQua","Species"))

# 2 Compute Prop_CPUE_Length_Year in cpue.length.year
cpue.length.year <- cpue.length.year %>% 
  mutate(Prop_CPUE_Length_Year = CPUE_Length_Year / CPUE_Year)

#----------------------------------------
# Create log_CPUE_Year in cpue.year
cpue.year <- cpue.year %>% 
  mutate(log_CPUE_Year = log(CPUE_Year))

#---------------------------------------

# Create scaleed log_CPUE_Year in cpue.length.year

# 1 scale function
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

# 2 Scale
cpue.length.year <- cpue.length.year %>% 
  group_by(Region,Species,Length) %>%
  mutate(CPUE_Length_Year_scale_log=
           scale_this(log(CPUE_Length_Year)))

```




# Compute length richness, shannon & mean age over time and incorporate to cpue.year
```{r}

# Compute size index over year from 10 Length classes 
size.index.year <- cpue.length.year %>%
  mutate(p=CPUE_Length_Year/CPUE_Year) %>%
  group_by(Region, Species, YearQua) %>%
  summarize(Shannon_10Length = sum(-p*log(p), na.rm=T),
            Mean_age_10Length = sum(Length*CPUE_Length_Year)/sum(CPUE_Length_Year)) 

# Compute size index from raw Lngt class
size.index.year.Lngt <-cpue.lngt.yearqua %>%
  mutate(p=CPUE_Lngt_YearQua/CPUE_All_Lngt_Yearqua) %>%
  group_by(Region, Species, YearQua) %>%
  summarize(Shannon_RawLngt = sum(-p*log(p), na.rm=T),
            Richness_size_RawLngt = n_distinct(LngtClass),
            Mean_age_RawLngt = sum(LngtClass*CPUE_Lngt_YearQua)/sum(CPUE_Lngt_YearQua)) 

# Incorporate above to cpue.year
cpue.year <- full_join(cpue.year,size.index.year,
                       by=c("Region", "Species", "YearQua"))

cpue.year <- full_join(cpue.year,size.index.year.Lngt,
                       by = c("Region", "Species", "YearQua"))

```  


# Compute home range and incorporate to cpue.year
```{r}

home.range.year <- cpue.subarea.yearqua %>%
  group_by(Region, Species, YearQua) %>%
  # use n_distinct(SubArea) to count the number of SubAreas
  summarise(Number_Subarea_All_Length=n_distinct(SubArea))

# incorporate to cpue.year
cpue.year <- full_join(cpue.year,home.range.year ,
                       by = c("Region", "Species", "YearQua"))

```


# Compute Num_SubArea and add to cpue.length.year
```{r}

# Compute Num_SubArea_Length, add to cpue.length.year
num.subarea.length <- cpue.length.subarea.yearqua %>%
  group_by(Region, Species, YearQua, Length) %>%
  summarise(Num_SubArea_Length = n_distinct(SubArea)) 

cpue.length.year <- 
  left_join(cpue.length.year, num.subarea.length, 
            by = c("Region","Species", "YearQua","Length"))


# add Number_SubArea_All_Length from home.range.year to cpue.length.year
cpue.length.year <- 
  left_join(cpue.length.year, home.range.year, 
            by = c("Region", "Species", "YearQua"))
 
 
# Compute proportion of Num_SubArea over Num_SubArea_All_Length
cpue.length.year <- cpue.length.year %>% 
  mutate(Prop_SubArea_Length = Num_SubArea_Length / Number_Subarea_All_Length) %>% 
  ungroup(Length) %>% 
  mutate(Length = factor(
    Length, levels=c("0","1","2","3","4",
                     "5","6","7","8","9",
                     "10","11","12","13","14","15",
                     "16","17","18","19")))

```

# Compute Mean_Prop_SubArea and add to cpue.year
```{r}
# Compute Mean_Prop_Subarea
cpue.length.year.mean <-
  cpue.length.year %>% 
  group_by(Region,Species,YearQua) %>% 
  summarise(Mean_Prop_SubArea = mean(Prop_SubArea_Length),
            new = list(mean_se(Prop_SubArea_Length))) %>%
  unnest(new)


cpue.length.year.mean <-
  cpue.length.year.mean %>% 
  select(-y) %>% 
  rename(Min_Prop_SubArea = ymin,
         Max_Prop_SubArea = ymax)
  
  
cpue.year <- 
  left_join(cpue.year, cpue.length.year.mean, 
            by = c("Region","Species", "YearQua"))

```


# Compute standardized subarea from maximum range of the corresponding size group

```{r}

# 1 extract maximum range of size group over time then add to cpue.length.year

max.subarea.length <- num.subarea.length %>% 
  group_by(Region, Species, Length) %>% 
  summarise(Max_SubArea_Length = max (Num_SubArea_Length)) %>% 
  mutate_at("Length", as.factor)

cpue.length.year <- 
  left_join(cpue.length.year, max.subarea.length, 
            by = c("Region","Species", "Length"))

  
# 2 Compute standardized subarea length 
cpue.length.year <- cpue.length.year %>% 
  group_by(Region, Species, YearQua, Length) %>% 
  mutate(Stan_SubArea_Length = 
           Num_SubArea_Length / Max_SubArea_Length)


# 3 Compute mean standardized subarea and add to cpue.year
Stan_Subarea <- cpue.length.year %>% 
  group_by(Region, Species, YearQua) %>% 
  summarise(Mean_Stan_SubArea = mean(Stan_SubArea_Length))

cpue.year <- 
  left_join(cpue.year, Stan_Subarea, 
            by = c("Region","Species","YearQua"))

```

# Compute pairwise habitat overlap (average.out)

```{r }

# All 190 combinations 
#combn(0:19,2)

out <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # Subarea of length group x
  cpue.x <- cpue.length.subarea.yearqua %>%
  group_by(Region,Species,YearQua) %>%
  filter(Length==x & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # Subarea of length group y
  cpue.y <- cpue.length.subarea.yearqua %>%
  group_by(Region,Species,YearQua) %>%
  filter(Length==y & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # intersect (#@ add .groups to eliminate warning )
  intersect <- 
  dplyr::intersect(cpue.x, cpue.y) %>%
  group_by (Region, Species, YearQua) %>%
  summarise(Number_intersect=n_distinct(SubArea),
            .groups = "drop")
  
  # union (#@ add .groups to eliminate warning )
  union <- 
  dplyr::union(cpue.x, cpue.y) %>%
  group_by (Region, Species,YearQua) %>%
  summarise(Number_union=n_distinct(SubArea),
            .groups = "drop")

  # overlap
  overlap <- 
    full_join(intersect,union,
              by=c("Region","Species", "YearQua")) %>%
    replace_na(list(Number_intersect = 0)) %>%
    mutate(Area_overlap = Number_intersect / Number_union) 

  # Add x and y column (pair length)
  overlap <- overlap %>% add_column(x, y)
  
  # store in List
  out[[i]] <- overlap
  
}

out.all<-bind_rows(out,.id = "id") # id is combination of pairs

out.all.overlap <-out.all

# Calculate average area overlap among all combinations
average_out<-out.all %>%
  group_by(Region, Species,YearQua) %>%
  summarize(Mean_intersect = mean(Number_intersect),
            Mean_union = mean(Number_union),
            Paired_habitat_overlap = mean(Area_overlap, na.rm = T),
            # use mean_se() to create mean, min, and max area_overlap
            new = list(mean_se(Area_overlap)),
            .groups = "drop") %>%
  unnest(new) 

# incorporate average.out with cpue.yearqua
average_out_arranged <- average_out %>% 
  # remove y from new as is same as Mean_Area_Overlap
  select(-y) %>%  
  rename(Min_Paired_habitat_overlap = ymin,
         Max_Paired_habitat_overlap = ymax)
  
  cpue.year <- full_join(cpue.year,average_out_arranged, 
                       by = c("Region", "Species","YearQua"))

out.all %>% group_by(Species,YearQua) %>% 
  summarise(number_of_id = n_distinct(id))
  

```



# Compute habitat overlap using habitat area of one class as demoninator
```{r }

# Total 190 combinations
# combn(0:19,2)

out_deno <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # Subarea of length group x
  cpue.x <- cpue.length.subarea.yearqua %>%
  group_by(Species,YearQua) %>%
  filter(Length==x & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # Subarea of length group y
  cpue.y <- cpue.length.subarea.yearqua %>%
  group_by(Species,YearQua) %>%
  filter(Length==y & CPUE_Length_Subarea_Yearqua>0) %>%
  dplyr::select(Region, Species, SubArea,YearQua)
  
  # intersect
  intersect <- 
  dplyr::intersect(cpue.x, cpue.y) %>%
  group_by (Region, Species, YearQua) %>%
  summarise(Number_intersect=n_distinct(SubArea),
             .groups = "drop")
  
  # denominator_x
  deno_x <- cpue.x %>% 
  group_by (Region, Species,YearQua) %>%
  summarise(Number_x = n_distinct(SubArea),
             .groups = "drop")

  # demoninator_y
  deno_y <- cpue.y %>% 
    group_by (Region, Species, YearQua) %>% 
    summarise(Number_y = n_distinct(SubArea),
               .groups = "drop")
  
  # join deno_x and deno_y
  deno <- full_join(deno_x, deno_y,
                    by = c("Region","Species", "YearQua"))
  
  # overlap_size_deno
  overlap_size_deno <- 
    full_join(intersect, deno,  
              by=c("Region","Species", "YearQua")) %>%
    replace_na(list(Number_intersect = 0)) %>%
    mutate(Area_overlap_deno_x = Number_intersect / Number_x,
           Area_overlap_deno_y = Number_intersect / Number_y) 

  # Add x and y column (pair length)
  overlap_size_deno <- overlap_size_deno %>% add_column(x, y)
  
  # store in List
  out_deno[[i]] <- overlap_size_deno
  
}

# bind lists by rows
out_deno_all<-bind_rows(out_deno,.id = "id") # id is combination of pairs

# create mean of Area_overlap_deno_x and Area_overlap_deno_y
out_deno_all <- out_deno_all %>% 
  mutate(Mean_Area_overlap_deno_xy = 
              1/2*(Area_overlap_deno_x + Area_overlap_deno_y))


# Calculate average area overlap among 190 combinations
average_out_deno_out <- out_deno_all %>%
  group_by(Region, Species,YearQua) %>%
  # use mean_se() to create mean, min, and max area_overlap
  summarize(Paired_habitat_overlap_deno = 
              mean(Mean_Area_overlap_deno_xy, na.rm = T),
            new = list(mean_se(Mean_Area_overlap_deno_xy)),
             .groups = "drop") %>%
  unnest(new) 


# incorporate average_out_deno_out with cpue.yearqua
average_out_deno_out <- average_out_deno_out %>% 
  # remove y from new as is same as Mean_Area_Overlap_deno
  select(-y) %>%  
  rename(Min_Paired_habitat_overlap_deno = ymin,
         Max_Paired_habitat_overlap_deno = ymax)
  
  
cpue.year <- full_join(cpue.year,average_out_deno_out, 
                       by = c("Region", "Species","YearQua"))

```



# Calculate lat lon centroid 

```{r}

# Add lon, lat
cpue.length.subarea.yearqua.geo <- 
  cpue.length.subarea.yearqua %>% 
  mutate(lon = ices.rect(SubArea)$lon,
         lat = ices.rect(SubArea)$lat)

# calculate CPUE-weighted mean lon and lat for each length
cpue.length.subarea.yearqua.geo.mean <-
  cpue.length.subarea.yearqua.geo %>% 
  group_by(Region, Species, YearQua,Length) %>% 
  summarise(
    Centroid_lon = sum(CPUE_Length_Subarea_Yearqua * lon)/
      sum(CPUE_Length_Subarea_Yearqua),
    Centroid_lat = sum(CPUE_Length_Subarea_Yearqua * lat)/
      sum(CPUE_Length_Subarea_Yearqua)) %>%
  ungroup() %>% 
  mutate_at('Length',as.factor)
  

# Add to cpue.length.yearqua
cpue.length.year <- 
  full_join(cpue.length.year,
            cpue.length.subarea.yearqua.geo.mean,
            by=c("Region", "Species", "YearQua","Length"))  


```


# Compute pairwise distance in centroid

```{r}

# All 190 pair combinations

# combn(0:19,2)

out_centroid <- vector(mode = "list")

for (i in 1:190){
  # select two length from 45 combinations
  x <- combn(0:19, 2)[,i][1] 
  y <- combn(0:19, 2)[,i][2]
  
  # subset of length group x
  lon.lat.x <- cpue.length.year %>%
    group_by(Region,Species,YearQua) %>%
    filter(Length == x) %>% 
    dplyr::select(Region, Species, Length,YearQua, 
                  Centroid_lon, Centroid_lat)
  
  # subset of length group y
  lon.lat.y <- cpue.length.year %>%
    group_by(Region,Species,YearQua) %>%
    filter(Length == y) %>% 
    dplyr::select(Region, Species, Length,YearQua, 
                  Centroid_lon, Centroid_lat)
  
  # join x and y
  lon.lat.xy <- 
    full_join(lon.lat.x, lon.lat.y,
              by=c("Region","Species", 
                   "YearQua"))

  # Absoluate distance between centroids
  lon.lat.xy <- lon.lat.xy %>% 
    mutate(Distance_lon = abs(Centroid_lon.x - Centroid_lon.y),
           Distance_lat = abs(Centroid_lat.x - Centroid_lat.y)) 

  # Add x and y column (pair length)
  lon.lat.xy <- lon.lat.xy %>% add_column(x, y)
  
  # store in List
  out_centroid[[i]] <- lon.lat.xy
  
}


out_centroid_all<-bind_rows(out_centroid,.id = "id") # id is combination of pairs


# Calculate average area overlap among 45 combinations
average_out_centroid <- out_centroid_all %>%
  group_by (Region, Species,YearQua) %>%
  summarize(new = list(mean_se(Distance_lon)),
            new1 = list(mean_se(Distance_lat))) %>%
  unnest(new) %>% 
  rename(Mean_paired_lon_distance = y,# delete this later
         Min_paired_lon_distance = ymin,
         Max_paired_lon_distance = ymax) %>% 
  unnest(new1) %>% 
    rename(Mean_paired_lat_distance = y,# delete this later
         Min_paired_lat_distance = ymin,
         Max_paired_lat_distance = ymax) 
    

# incorporate average_out_centroid with cpue.year
  
cpue.year <- full_join(cpue.year,average_out_centroid, 
                       by = c("Region", "Species","YearQua"))



```

# Create cpue.pair for model purpose
```{r}

# retain useful variables for 3 tibbles
out.all.overlap <- out.all.overlap %>% 
  select(- Number_intersect, - Number_union)
  
out_deno_all <- out_deno_all %>% 
  select(- Area_overlap_deno_x, - Area_overlap_deno_y,
         - Number_intersect, - Number_x, - Number_y,
         )
  
out_centroid_all <- out_centroid_all %>% 
  select(id,Region,Species,YearQua,Distance_lon,
         Distance_lat,x, y)

# bind 3 tibbles
out_temp <- left_join(out.all.overlap,out_deno_all,
          by = c ("id","Region","Species","YearQua",
                  "x","y"))

cpue.pair <- left_join(out_temp, out_centroid_all,
          by = c ("id","Region","Species","YearQua",
                  "x","y"))

# select variables
cpue.pair <- cpue.pair %>% 
  rename(Pair_id = id) 

```


# Rename cpue.year variables
```{r}

cpue.year <- cpue.year %>% 
  rename(Regional_Shannon = Shannon_RawLngt,
         Regional_size_richness = Richness_size_RawLngt,
         Regional_mean_size= Mean_age_RawLngt)

```


# Add time index basd on North Sea 3 species survey year 1977-2019

Replace YearQua to TimeIndex, add Year & Quarter to tibbles
```{r}

# Add Year, Quarter to all tibbles
cpue.lngt.yearqua <- cpue.lngt.yearqua %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.length.subarea.yearqua <- cpue.length.subarea.yearqua %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.length.year<- cpue.length.year %>% 
   separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)

cpue.year <-cpue.year %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)
  
cpue.pair <- cpue.pair %>% 
  separate(YearQua, c("Year", "Quarter"), remove =F) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Quarter",as.numeric)
  
``` 


# Add fishing mortality & TSB data
```{r}

FishingM <-read.csv("a0_ices_raw_data/Fishing_Mortality.csv")

FishingM <- FishingM %>% 
  mutate_at("Species", as.factor) %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("TSB_Tonnes", as.numeric)

cpue.year <- left_join(cpue.year, FishingM, by = c("Year", "Species"))

cpue.length.year <- left_join(cpue.length.year, FishingM, by = c("Year", "Species"))

cpue.pair <- left_join(cpue.pair,FishingM, by = c("Year","Species"))


cpue.year <- cpue.year %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

cpue.length.year <- cpue.length.year %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

cpue.pair <- cpue.pair %>% 
  ungroup() %>% 
  mutate_at("Species", as.factor)

```


# Add sea bottom temperature data
Variable name: MeanBT,CVofBT
```{r}

# Read self compiled bottomT data 1977-2019
Temp_NS<-read.csv("a0_ices_raw_data/bottomT_NS_1977_2019.csv")

# Add to cpue.length.year
cpue.length.year <- left_join(cpue.length.year, Temp_NS,
          by=c("Year","Quarter"))

# Add to cpue.year
cpue.year <- left_join(cpue.year, Temp_NS,
          by=c("Year","Quarter"))

# Add to cpue.pair
cpue.pair <- left_join(cpue.pair,Temp_NS,
                                  by = c("Year","Quarter"))


```


# Change scale of survey year
```{r}
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

# Create Year.scale as centered year
Year.scale <-  tibble(Year = seq(1977,2019,1))
Year.scale <-  Year.scale %>% mutate(Year_scale_centered=scale_this(Year))

#1 cpue.year
cpue.year <- cpue.year %>% 
  mutate(MeanBT_scale = scale_this(MeanBT)) %>% 
  mutate(TSB_Tonnes_scale = scale_this(TSB_Tonnes))
  

cpue.year <- left_join(cpue.year,Year.scale,
                       by = "Year")

#2 cpue.pair
cpue.pair <- cpue.pair %>% 
  mutate(MeanBT_scale = scale_this(MeanBT)) %>% 
  mutate(TSB_Tonnes_scale = scale_this(TSB_Tonnes))
  

cpue.pair <- left_join(cpue.pair,Year.scale,
                       by = "Year")

#3 cpue.length.year
cpue.length.year <- left_join(cpue.length.year,Year.scale,
                              by = "Year")

```


# Save as RData
```{r}

# 20 Length
save(cpue.lngt.subarea.yearqua, cpue.lngt.yearqua, cpue.length.subarea.yearqua, cpue.length.year, cpue.year, cpue.pair,
     file = "a_RData_3Species/20_Length.RData")

```


# load RData
```{r}

load("a_RData_3Species/20_Length.RData")

```

#------------- Results -----------------------

#-----Fig 1 a-c overlap over time

# lmer logit (Year|Length)
```{r message = FALSE}

Area_overlap_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Area_overlap) ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  R2_m <- r.squaredGLMM(m)[1,1]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap",
         F_value,p_value, R2_c, R2_m,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_o <- Area_overlap_function("Atlantic cod",cpue.pair)
haddock_o <- Area_overlap_function("Haddock",cpue.pair)
whiting_o <- Area_overlap_function("Whiting",cpue.pair)
model.overlap.output <- rbind(cod_o, haddock_o, whiting_o)



# Overlap_deno
Area_overlap_deno_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Mean_Area_overlap_deno_xy) ~
              Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  R2_m <- r.squaredGLMM(m)[1,1]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap_deno",
         F_value,p_value, R2_c,R2_m,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_d <- Area_overlap_deno_function("Atlantic cod",cpue.pair)
haddock_d <- Area_overlap_deno_function("Haddock",cpue.pair)
whiting_d <- Area_overlap_deno_function("Whiting",cpue.pair)
model.overlap.output.deno <- rbind(cod_d, haddock_d, whiting_d)

# output table combine
model.overlap.output.all <- rbind(model.overlap.output,model.overlap.output.deno)

```


# Model diagnostics
Code to diagnose model for each species  
```{r eval = FALSE}
## Response: Area_overlap, Mean_Area_overlap_deno_xy
cpue.pair.cod <- cpue.pair %>% 
  filter(Species == "Atlantic cod") 

cpue.pair.haddock <- cpue.pair %>% 
  filter(Species == "Haddock") 

cpue.pair.whiting <- cpue.pair %>% 
  filter(Species == "Whiting") 

m1 <- lmer(logit(Mean_Area_overlap_deno_xy) ~ 
             Year_scale_centered+
            (Year_scale_centered|Pair_id),
            cpue.pair.whiting)
summary(m1)
coef(m1)$Pair_id %>%
  summarise(mean = mean(Year_scale_centered))
plot(m1)
r.squaredGLMM(m1) 

simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 

```


# Model prediction for fixed effect
```{r}

# prediction for all species for area_overlap
mod_overlap <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Area_overlap
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

# prediction for all species for area_overlap_deno
mod_overlap_deno <- function(species){
  d1 <- cpue.pair %>% filter(Species == species) 
  x <- cpue.pair %>% filter(Species == species) %>% pull(Year)
  y <- cpue.pair %>% filter(Species == species) %>% pull(Mean_Area_overlap_deno_xy)
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)}

mod.overlap <- rbind(mod_overlap("Atlantic cod"),
      mod_overlap("Haddock"),
      mod_overlap("Whiting"))

mod.overlap <- tibble(Response = "Area_overlap", mod.overlap)

mod.overlap.deno <- rbind(mod_overlap_deno("Atlantic cod"),
                          mod_overlap_deno("Haddock"),
                          mod_overlap_deno("Whiting"))

mod.overlap.deno <- tibble(Response = "Area_overlap_deno",
                            mod.overlap.deno)

mod.overlap.all <- rbind(mod.overlap,mod.overlap.deno)

```

# Fig 1 a-c

```{r message =FALSE}

# Plot Area_overlap
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Area_overlap * 100)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.overlap,
            aes(x = x,
                y = exp(Fitted)/(1+exp(Fitted))*100),
            color = "black", size = 1.5)+
  facet_wrap(vars(Species))+#<Function>: get overlap Infos for paired cpue.group data
  scale_color_viridis_d(alpha = .3) +
  xlab("Year") +
  ylab("Pairwise range overlap") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        panel.spacing = unit(0.9, "lines"),
        strip.text.x = element_text(size = 11))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))
        
# Plot Area_overlap_deno
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), 
           y = Mean_Area_overlap_deno_xy * 100)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.overlap.deno,
            aes(x = x,
                y = exp(Fitted)/(1+exp(Fitted))*100),
            color = "black", size = 1.5)+
  facet_wrap(vars(Species))+
  scale_color_viridis_d(alpha = .3) +
  xlab("Year") +
  ylab("Pairwise range overlap deno") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))

```




#------Fig 1 d-f Range of individual size

# lmer logit (Year|Length)
```{r}

Range_size_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(logit(Stan_SubArea_Length) ~ Year_scale_centered +
              (Year_scale_centered|Length),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Range_overlap",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_s <- Range_size_function("Atlantic cod",cpue.length.year)
haddock_s <- Range_size_function("Haddock",cpue.length.year)
whiting_s <- Range_size_function("Whiting",cpue.length.year)
model.RangeSize.output <- rbind(cod_s, haddock_s, whiting_s)

```

# Model diagnostics
Code to diagnose model for individual species  

```{r eval = FALSE}

data.cod <- cpue.length.year %>% 
  filter(Species == "Atlantic cod")

data.haddock <- cpue.length.year %>% 
  filter(Species == "Haddock") 

data.whiting <- cpue.length.year %>% 
  filter(Species == "Whiting") 

# glmer
m1 <- glmer(Stan_SubArea_Length ~ Year_scale_centered +
              (1|Length), family = binomial, data.cod)
summary(m1)
r.squaredGLMM(m1)
plot(m1)
simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 


# lmer logit
m1 <- lmer(logit(Stan_SubArea_Length) ~ 
             Year_scale_centered+
            (Year_scale_centered|Length),
            data.haddock)
summary(m1)
anova(m1)
coef(m1)$Length %>%
  summarise(mean = mean(Year_scale_centered))
plot(m1)
r.squaredGLMM(m1) 
simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 
```


# Model prediction for fixed effect
```{r}

# prediction for all species
model_prediction_RS <- function(species){
  dd <- cpue.length.year %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Stan_SubArea_Length
  m <- lm(logit(y)~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble.model <- tibble(Species = species, model.fit)
  rename(tibble.model, xvar = x)
  }

prediction.cod.RS <- model_prediction_RS("Atlantic cod")
prediction.haddock.RS <- model_prediction_RS("Haddock")
prediction.whiting.RS <- model_prediction_RS("Whiting")

prediction.3species.RS <- 
rbind(prediction.cod.RS,
      prediction.haddock.RS,
      prediction.whiting.RS)

```


# Fig1 d-f. Range size

```{r message = FALSE}

# Order size groups
cpue.length.year <- cpue.length.year %>% 
  mutate(
    Length = factor
    (Length,levels=c("0","1","2","3","4","5","6",
                     "7","8","9","10","11","12","13",
                     "14","15","16","17","18","19")))

# Plot
ggplot(data = cpue.length.year,
       aes(x = as.numeric(YearQua), 
           y = Stan_SubArea_Length * 100)) +
  facet_wrap(~Species)+
  geom_line(aes(color = Length))+
  # Solid line for Atlantic cod and haddock
  geom_line(data = prediction.3species.RS%>% 
              filter (Species %in% c("Atlantic cod", "Haddock")),
            aes(x = xvar,
                y = (exp(Fitted)/(1+exp(Fitted)))*100),
            color = "black", size = 1.5)+
  scale_color_viridis_d(alpha = .5)+
  xlab("Year") +
  ylab("Standardized distriubtion range") +
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     limits = c(0,120))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  theme(legend.position = "none")

```


#----- Fig 1 g-i Paired disance 

# lmer logit (Year|Length)
```{r}

Lon_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(Distance_lon ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Distance_lon",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_lon <- Lon_function("Atlantic cod",cpue.pair)
haddock_lon <- Lon_function("Haddock",cpue.pair)
whiting_lon <- Lon_function("Whiting",cpue.pair)
model.lon.output <- rbind(cod_lon, haddock_lon, whiting_lon)



Lat_function <- function(species, dd){
  dd.species <- dd %>% filter(Species ==species)
  m <- lmer(Distance_lat ~ Year_scale_centered +
              (Year_scale_centered|Pair_id),dd.species)
  F_value <- anova(m)[1,5]
  p_value <- anova(m)[1,6]
  R2_c <- r.squaredGLMM(m)[1,2]
  Fixed_estimate <- coef(summary(m))[2,1]
  Conf_2.5 <- confint(m)[6,1]
  Conf_97.5 <- confint(m)[6,2]
  tibble(Species = species,
         Response = "Distance_lat",
         F_value,p_value, R2_c,
         Fixed_estimate, Conf_2.5, Conf_97.5)
  }

cod_lat <- Lat_function("Atlantic cod",cpue.pair)
haddock_lat <- Lat_function("Haddock",cpue.pair)
whiting_lat <- Lat_function("Whiting",cpue.pair)
model.lat.output <- rbind(cod_lat, haddock_lat, whiting_lat)

# Combine lon+lat output
model.dist.output <- rbind(model.lon.output,
                           model.lat.output)

```


# Model diagnostics
Code to diagnose model for individual species  

```{r eval = FALSE}
## Response: Area_overlap, Mean_Area_overlap_deno_xy
cpue.pair.cod <- cpue.pair %>% 
  filter(Species == "Atlantic cod") 

cpue.pair.haddock <- cpue.pair %>% 
  filter(Species == "Haddock") 

cpue.pair.whiting <- cpue.pair %>% 
  filter(Species == "Whiting") 

m1 <- lmer((Distance_lon) ~ 
             Year_scale_centered+
            (Year_scale_centered|Pair_id),
            family = poisson,
            cpue.pair.haddock)
summary(m1)
coef(m1)$Pair_id %>%
  summarise(mean = mean(Year_scale_centered))
plot(m1)
r.squaredGLMM(m1) 

simulationOutput <- simulateResiduals(fittedModel = m1)
plot(simulationOutput) 


```


# Model prediction for fixed effect
```{r}

# Model prediction lon

mod_lon <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Distance_lon
  m <- lm(y~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

mod.lon.all <- rbind(mod_lon("Atlantic cod"),
                     mod_lon("Haddock"),
                     mod_lon("Whiting"))


# Model prediction lat

mod_lat <- function(species){
  dd <- cpue.pair %>% filter(Species == species) 
  x <- dd$Year
  y <- dd$Distance_lat
  m <- lm(y~x)
  model.fit <- data.frame(x = seq(min(x), max(x), by = 0.01))
  model.fit <- transform (model.fit, Fitted =predict(m,model.fit))
  model.fit
  tibble(Species = species, model.fit)
  }

mod.lat.all <- rbind(mod_lat("Atlantic cod"),
                     mod_lat("Haddock"),
                     mod_lat("Whiting"))

```


# Fig 1g-i Paired_lon/lat
```{r message =FALSE}

# Check max lon and lat
cpue.pair %>%
  summarise(lon_max = max(Distance_lon, na.rm = T),
            lat_max = max(Distance_lat, na.rm = T))

# Lon
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Distance_lon )) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.lon.all %>% 
              filter(Species %in% c("Haddock","Whiting")),
            aes(x = x,
                y = Fitted), size = 1.5)+
  facet_wrap(vars(Species))+
  xlab("Year") +
  ylab("Distance_lon") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 9, by = 3),
                     limits = c(0,12))

# Lat
ggplot(data = cpue.pair,
       aes(x = as.numeric(Year), y = Distance_lat)) +
  geom_line(aes(group = Pair_id),color = "gray", size = 0.1)+
  geom_line(data = mod.lat.all,
            aes(x = x,
                y = Fitted), size = 1.5)+
  facet_wrap(vars(Species))+
  xlab("Year") +
  ylab("Distance_lat") + theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = seq(0, 9, by = 3),
                     limits = c(0,12))



```


#----- Fig 2a-c slope for each size group pair 

# Exract pairwise slope
```{r eval=F}

#-------- Extract slope from lm (overlap ~ time)

## 1 nest data 
n_overlap <- out.all %>% 
  #ungroup(YearQua) %>% 
  mutate_at('YearQua', as.numeric) %>% 
  group_by(Region,Species, x, y) %>% 
  nest() 

## 2 Apply regression
fun_overlap <-function(df) lm (Area_overlap ~ YearQua, data = df)

m_overlap <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap))


## 3 Extract slope and confidence interval of slope
slope_fun <- function(mod) coefficients(mod)[[2]]
#ci_lower_fun <- function(mod) confint(mod)[2,1]
#ci_upper_fun <- function(mod) confint(mod)[2,2]

m_overlap_summary <- m_overlap %>% 
  transmute(., slope = map_dbl(model, slope_fun)
            #,lower_ci = map_dbl(model, ci_lower_fun),
            #upper_ci = map_dbl(model, ci_upper_fun)
            )

#----------Check model fit

m_overlap_all <- n_overlap %>% 
  mutate(model = purrr::map(data, fun_overlap),
         tidied = purrr::map(model, tidy),
         glanced = purrr::map(model, glance),
         augmented = purrr::map(model, augment))

m_overlap_all %>%
  unnest(tidied)

m_overlap_all %>%
  unnest(augmented)

# p-value, r-square, adjusted r-square
overlap_statistics_table <-
m_overlap_all %>%
  unnest(glanced) %>% 
  select(Region, Species, x,y,r.squared,
         adj.r.squared, p.value)

```

# Fig 2a-c
```{r}

# select slope column & filter size class
m_overlap_summary <- 
  m_overlap_summary %>% 
  # Select slope column
  select(Region,Species, x, y, slope) 

# add autocorrelation
auto_dd <- tibble(Region = "North Sea", 
       Species = rep(c("Atlantic cod", "Haddock", "Whiting"),20),
       x = rep(c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19),
               each = 3),
       y = rep(c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19),
               each = 3),
       slope = 0)

summary.auto <- bind_rows(m_overlap_summary, auto_dd)

#--------- Prepare dataframe
corr.data  <- summary.auto %>% 
  ungroup(Region) %>% 
  select(-Region)

## transform data from long to wide
corr.data  <- # long to wide form
  pivot_wider(corr.data, 
              names_from = y, 
              values_from = slope)

## replace NA to 0 (NA from another side of wide form)
corr.data <- corr.data %>% 
  replace(is.na(.), 0) 

# Color for plotting correlogram
col2 <- colorRampPalette(c("#053061","#2166AC","#4393C3","#92C5DE","#D1E5F0", "#FFFFFF", "#FDDBC7","#F4A582", "#D6604D", "#B2182B","#67001F"))

# color limits
m_overlap_summary %>% 
  ungroup() %>% 
  summarise(min = min(slope),
            max = max(slope))

# Data by species
dd.cod <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Atlantic cod")
dd.cod<- dd.cod[,-c(1,2)]  
dd.cod <- as.matrix(dd.cod)
rownames(dd.cod) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.cod


dd.haddock <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Haddock")
dd.haddock<- dd.haddock[,-c(1,2)]  
dd.haddock <- as.matrix(dd.haddock)
rownames(dd.haddock) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.haddock

dd.whiting <- corr.data %>% 
  ungroup() %>% 
  filter (Species == "Whiting")
dd.whiting  <- dd.whiting [,-c(1,2)]  
dd.whiting<- as.matrix(dd.whiting )
rownames(dd.whiting ) <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
dd.whiting 

# Plot
par(mfrow = c(1,3))
p1 <- corrplot(dd.cod,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Atlantic cod"),
         mar=c(0,0,2,0)) 

p2 <- corrplot(dd.haddock,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(50), 
         title = paste0("Haddock"),
         mar=c(0,0,2,0)) 


p3 <- corrplot(dd.whiting ,
         method = "color", is.corr = FALSE,
         type = "upper",
         col.lim = c(-0.02,0.02), # for overlap
         col = col2(30), 
         title = paste0("Whiting"),
         mar=c(0,0,2,0)) 
 
```


#----- fig 2 d-f overlap by pairs of life stages

# plot function
```{r}

cpue.pair.other <- cpue.pair %>% 
  group_by(Region, Species, Year,x) %>% 
  summarise(mean_overlap_with_other= mean(Area_overlap)) %>% 
  mutate_at('x',as.factor)

cpue.pair.other.cod <- 
  cpue.pair.other %>% filter(Species == "Atlantic cod") 

plot_fun <- function(species){
  d1 <- cpue.pair.other %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = mean_overlap_with_other, colour = x))+
  geom_point() +
  geom_line(aes(colour = x))+
  geom_smooth(method='loess', formula= y~x)+
  geom_smooth(method='loess', formula= y~x, color = "black")}


```

# Fig 2 d-f plot mature-mature, juv-juv, mature-juv
group at maturation: 7, 8, 7 for cod, haddock, whiting, respectively.
```{r}

#1 replace x with mature or juv
juv_adu_fun <- function(species, group.at.maturity) {
  cpue.pair %>% filter(Species == species) %>% 
  mutate(x_stage = replace(x, x < group.at.maturity,"juv")) %>% 
  mutate(x_stage = replace(x_stage, x >= group.at.maturity, "adu")) %>% 
  mutate(y_stage = replace(y, y < group.at.maturity,"juv")) %>% 
  mutate(y_stage = replace(y_stage, y >= group.at.maturity, "adu"))
    }

d1 <- juv_adu_fun("Atlantic cod", 7)
d2 <- juv_adu_fun("Haddock", 8)  
d3 <- juv_adu_fun("Whiting", 7)

dd.juv.adu <- rbind(d1,d2,d3)


#2 create three caterogies
dd.juv.adu.1 <- dd.juv.adu %>% 
  mutate(stage ="a") %>% 
  mutate(stage = replace(stage, x_stage =="juv" & y_stage == "juv", "juv_juv")) %>% 
   mutate(stage = replace(stage, x_stage =="juv" & y_stage == "adu", "juv_adu")) %>% 
   mutate(stage = replace(stage, x_stage =="adu" & y_stage == "adu", "adu_adu")) %>% 
  filter(stage != "a")
  
# aggregate based on three caterogies  
cpue.pair.stage <- dd.juv.adu.1 %>% 
  ungroup() %>% 
  group_by(Region, Species, Year, stage) %>% 
  summarise(mean_overlap = mean(Area_overlap))


plot_fun <- function(species){
  d1 <- cpue.pair.stage %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = mean_overlap, colour = stage))+
  geom_point() +
  geom_line(aes(colour = stage))+
  geom_smooth(method='lm', formula= y~x)+ theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))
    }


plot_fun("Atlantic cod")
plot_fun("Haddock")
plot_fun("Whiting")

```


#-----Fig 3 Relationship between spatial indicies


# model
```{r}

# 1 Calculate AR for overlap & overlap_deno
cpue.year.ar <- cpue.year %>% 
  group_by(Species, Region) %>% 
  # Calculate overlap AR
  mutate(ar1_over = lag(Paired_habitat_overlap),
         ar2_over = lag(ar1_over),
         ar3_over = lag(ar2_over),
         ar4_over = lag(ar3_over)) %>% 
  # Calculate overlap first difference as model response variable
  mutate(diff_over = Paired_habitat_overlap - ar1_over) %>%
  # Overlap_deno AR
  mutate(ar1_deno = lag(Paired_habitat_overlap_deno),
         ar2_deno = lag(ar1_deno),
         ar3_deno = lag(ar2_deno),
         ar4_deno = lag(ar3_deno)) %>% 
  # Overlap_deno first difference as model response variable
  mutate(diff_deno = 
           Paired_habitat_overlap_deno - ar1_deno)


# 2 Standardize (scale_this)
cpue.year.ar <- cpue.year.ar %>% 
  group_by(Species, Region) %>% 
  mutate(
    s_SubArea = scale_this(Mean_Stan_SubArea),
    s_LonDist = scale_this(Mean_paired_lon_distance),
    s_LatDist = scale_this(Mean_paired_lat_distance))

# 3 Subset needed variables
cpue.year.ar <- cpue.year.ar %>% 
  select(Species,Year,Paired_habitat_overlap, 
         Paired_habitat_overlap_deno,
         diff_over,ar1_over,ar2_over,ar3_over,
         ar4_over, diff_deno,ar1_deno,ar2_deno,
         ar3_deno,ar4_deno,s_SubArea,s_LonDist,
         s_LatDist)

# 4 Subset to species
dd.cod <- cpue.year.ar %>% 
  filter(Species == "Atlantic cod")

dd.haddock <- cpue.year.ar %>% 
  filter(Species == "Haddock")

dd.whiting <- cpue.year.ar %>% 
  filter(Species =="Whiting")


# 5 Check corr between Stan_range, lon_distance, lat_distance

cor(dd.cod[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.haddock[,c("s_SubArea","s_LonDist","s_LatDist")])
cor(dd.whiting[,c("s_SubArea","s_LonDist","s_LatDist")])


# 6 Function to model, statistics, and coef_table
## 1 Overlap
overlap_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Overlap
  m <- lm(diff_over ~ ar1_over +  
            s_SubArea +s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_over <- 
    tibble(Species = species,
           Response = "Overlap", 
           Explanatory = 
             c("SubArea", "LonDist","LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m),anova(m),summary(m),dd_over)
  
}


## 2 Deno
deno_model <- function(species){
  dd <- cpue.year.ar %>% 
    filter(Species == species)
  # Deno
  m <- lm(diff_deno ~ ar1_deno +  
            s_SubArea +s_LonDist + s_LatDist, dd)
  
  coef <- c(coef(m)[3],coef(m)[4],coef(m)[5])
  conf25 <- c(confint(m)[3,1],confint(m)[4,1],
            confint(m)[5,1])
  conf75 <- c(confint(m)[3,2],confint(m)[4,2],
            confint(m)[5,2])
  dd_deno <- 
    tibble(Species = species,
           Response = "Overlap_deno",
           Explanatory = 
             c("SubArea", "LonDist", "LatDist"),
           coef,conf25,conf75)
  
  # Statistics output
  list(vif(m), anova(m),summary(m),dd_deno)
  
}


overlap_model("Atlantic cod")
overlap_model("Haddock")
overlap_model("Whiting")
deno_model("Atlantic cod")
deno_model("Haddock")
deno_model("Whiting")


```


# Fig.3
```{r}

over.cod <- overlap_model("Atlantic cod")
over.had <- overlap_model("Haddock")
over.whi <- overlap_model("Whiting")
deno.cod <- deno_model("Atlantic cod")
deno.had <- deno_model("Haddock")
deno.whi <- deno_model("Whiting")


# Plot function
coef_plot <- function(species, dd.over, dd.deno){
  dd <- rbind(dd.over[[4]],dd.deno[[4]])
  pd <- position_dodge(width=0.8)
  dd$Explanatory <- factor(dd$Explanatory,
    levels = c('SubArea','LonDist','LatDist'),
    ordered = TRUE)
  ggplot(dd,aes(x = Explanatory, y = coef, group = Response))+
  geom_point(position = pd, aes(shape = Response),
             size = 2)+
    scale_shape_manual(values=c(0, 2))+
  geom_errorbar(aes(ymin = conf25, ymax= conf75),
                position = pd,
                width = 0.4,
                size = 0.7)+
    #facet_grid(. ~ "Atlantic cod")+
    #facet_grid(. ~ "Haddock")+
    facet_grid(. ~ "Whiting")+
    
  #scale_color_manual(values=c("coral","steelblue")) +
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"))+
    labs(y = "Model coefficient", x = "")+
    scale_x_discrete(labels = c('Range \n size',
              'Distance\n lon',
              'Distance\n Lat'))+
    scale_y_continuous(
      breaks = seq(-0.04, 0.12, 0.04),
      limits=c(-0.04, 0.12))+
    geom_hline(yintercept=0, linetype="dashed", color = "black")+
    theme(strip.text.x = element_text(size = 11))}

coef_plot("Atlantic cod", over.cod, deno.cod)
coef_plot("Haddock", over.had, deno.had)
coef_plot("Whiting", over.whi, deno.whi)

# Check R2 for plots
over.cod[[3]]$adj.r.squared
over.had[[3]]$adj.r.squared
over.whi[[3]]$adj.r.squared
deno.cod[[3]]$adj.r.squared
deno.had[[3]]$adj.r.squared
deno.whi[[3]]$adj.r.squared

# Check p-value
over.cod[[2]]
over.had[[2]]
over.whi[[2]]
deno.cod[[2]]
deno.had[[2]]
deno.whi[[2]]

```


#-----Fig 4 Size-specific pattern 
# individual model for each size group 
```{r}

# 2021.11.26 Create logit_Stan_SubArea_Length
cpue.length.year <- cpue.length.year %>% 
  mutate(Logit_Stan_SubArea_Length = 
           logit(Stan_SubArea_Length))

# Use gather to create a column with all Y-variables
cpue.length.year.y.gather <- cpue.length.year %>% 
  #ungroup(YearQua) %>% 
  mutate_at('Length', as.character) %>%
  mutate_at('YearQua', as.numeric) %>% 
  mutate(CPUE_Length_Year_log = log(CPUE_Length_Year)) %>% 
  filter(Length %in% c(0,1,2,3,4,5,6,7,8,9,10,
                       11,12,13,14,15,16,17,18,19)) %>% 
  gather(key="Variables", value="value",
         CPUE_Length_Year_log,Prop_CPUE_Length_Year,
         Num_SubArea_Length, Prop_SubArea_Length,
         Centroid_lon, Centroid_lat,
         Stan_SubArea_Length,
         Logit_Stan_SubArea_Length) 

# Re-order Length
cpue.length.year.y.gather <- cpue.length.year.y.gather %>% 
  mutate(Length = factor(Length, levels = c("0","1","2","3","4","5","6",
                              "7","8","9","10","11","12","13","14",
                              "15","16","17","18","19")))


# Split by Variables
## Use split + imap can generate automatic plot titles
cpue.length.year.pl <- cpue.length.year.y.gather %>% 
  split(list(cpue.length.year.y.gather$Variables,
             cpue.length.year.y.gather$Region))


# Create plot function
plot.fun <- function(.x,.y){
  ggplot(data=.x, aes(x=YearQua,y=value))+
    geom_point(size = 0.5, colour = "grey")+
    facet_grid(Species~Length,scales= "free_y")+   
    scale_y_continuous(name = element_blank()) +
    geom_smooth(method='lm', formula= y~x, color = "black")+
    xlab("Year") + theme + ggtitle(.y)
  }

# plot with imap
purrr::imap(cpue.length.year.pl,plot.fun)


```


# prepare slope data for plot

```{r}
theme <- 
  theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"),
    legend.position="none")


n.data <- cpue.length.year.y.gather %>% 
  group_by(Region, Species, Length, Variables) %>% 
  nest()


mod_fun <-function(df)lm(value ~ YearQua, data = df)

mod.data <- n.data %>% 
  mutate(model = purrr::map(data, mod_fun))

slope_fun <- function(mod) coefficients(mod)[[2]]
ci_lower_fun <- function(mod) confint(mod)[2,1]
ci_upper_fun <- function(mod) confint(mod)[2,2]


summarise.data <- mod.data %>% 
  dplyr::mutate(., slope = map_dbl(model, slope_fun),
            lower_ci = map_dbl(model, ci_lower_fun),
            upper_ci = map_dbl(model, ci_upper_fun))


```


# Fig.4
```{r}

# 1 Logit_Stan_SubArea_Length
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Logit_Stan_SubArea_Length")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Logit_Stan_SubArea_Length")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.08, 0, 0.08),
                     limits = c(-0.10,0.10)) +
  scale_x_discrete(limits = c(1,5,10,15,20))
  
 
# 2 Centroid_lon
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Centroid_lon")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Centroid_lon")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.10, 0, 0.10),
                     limits = c(-0.15,0.15)) +
  scale_x_discrete(limits = c(1,5,10,15,20))



# 3 Centroid_lat
dd <- summarise.data %>% 
  mutate_at('Length', as.numeric) %>%
  filter(Variables == "Centroid_lat")

ggplot(data=dd, aes(x = Length,y = slope))+
    geom_point(size = 0.7) + 
    geom_errorbar(aes(ymin=lower_ci, ymax=upper_ci), width=.2,
                 position=position_dodge(.9)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))+
  facet_grid(~Species, scales = "free")+
  #scale_x_continuous(n.breaks = 10)+
    geom_hline(yintercept=0, linetype='dotted')+
  ggtitle("Centroid_lat")+
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
  #scale_x_continuous(breaks = seq(1, 20, by = 5))+
  theme(panel.spacing = unit(0.9, "lines"))+
  theme(strip.text.x = element_text(size = 11))+
  scale_y_continuous(breaks = c(-0.10, 0, 0.10),
                     limits = c(-0.15,0.15)) +
  scale_x_discrete(limits = c(1,5,10,15,20))+
  xlab("Length group")

```


#-----Fig 4 & Table S4 model result 
0. ts plot
1. Detrend response variable by differencing
2. Predictor:Remove colinearity by substracting mean (check)
3. Fit the model and perform acf(resid(fit))
4. Fit again the model with ARMA (gls or astsa)
5. Decide the best ARMA using AIC (& check whitness)
6. Parsimonious model for predictors 

# Prepare data
response use first difference
explanatory use scaled, except cpue_length log transform
```{r}

# 1 Take first diff, create ar1
cpue.length.year.ar <- cpue.length.year %>% 
  mutate_at("Length", as.factor) %>% 
  mutate_at("Num_SubArea_Length", as.numeric) %>% 
  group_by(Species, Region,Length) %>%
  # 1. AR subarea
  mutate(ar1_area = lag(Stan_SubArea_Length),
         diff_area = Stan_SubArea_Length - ar1_area,
         ar2_area = lag(ar1_area),
         ar3_area = lag(ar2_area),
         ar4_area = lag(ar3_area)) %>% 
  # 2. AR lon
  mutate(ar1_lon = lag(Centroid_lon),
         diff_lon = Centroid_lon - ar1_lon,
         ar2_lon = lag(ar1_lon),
         ar3_lon = lag(ar2_lon),
         ar4_lon = lag(ar3_lon)) %>% 
  # 3. AR lat
  mutate(ar1_lat = lag(Centroid_lat),
         diff_lat = Centroid_lat - ar1_lat,
         ar2_lat = lag(ar1_lat),
         ar3_lat = lag(ar2_lat),
         ar4_lat = lag(ar3_lat)) %>% 
  # ungroup
  ungroup() %>% 
  # 4. log CPUE_Length_Year
  mutate(log_cpue = log(CPUE_Length_Year)) %>% 
  # 5. Scale fishing, TSB
  mutate(s_tsb = scale_this(TSB_Tonnes),
         s_temp = scale_this(MeanBT),
         s_fmor = scale_this(Fishing_Mortality)) %>% 
  # Select variables
  select(Species,Region,Length,
         Stan_SubArea_Length,
         ar1_area,diff_area,ar2_area,ar3_area, ar4_area,
         ar1_lon, diff_lon, ar2_lon,ar3_lon, ar4_lon,
         ar1_lat, diff_lat, ar2_lat,ar3_lat, ar4_lat,
         log_cpue, s_tsb,s_temp,s_fmor) 
  
  
cpue.length.year.ar

```


# Functions
```{r}

# check_ar_range
check_ar_range <- function(dd){
  mm1<-lm(diff_area ~  ar1_area, dd,
        na.action = na.omit)
  mm2<-lm(diff_area ~  ar1_area + ar2_area ,
        dd, na.action = na.omit)
  mm3<-lm(diff_area ~ ar1_area + ar2_area +
        ar3_area, dd, na.action = na.omit)
  mm4<-lm(diff_area ~  ar1_area + ar2_area +
          ar3_area + ar4_area, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
}

# check_ar_lon
check_ar_lon <- function(dd){
  mm1<-lm(diff_lon ~  ar1_lon, dd,
        na.action = na.omit)
  mm2<-lm(diff_lon ~  ar1_lon + ar2_lon ,
        dd, na.action = na.omit)
  mm3<-lm(diff_lon ~ ar1_lon + ar2_lon +
        ar3_lon, dd, na.action = na.omit)
  mm4<-lm(diff_lon ~  ar1_lon + ar2_lon +
          ar3_lon + ar4_lon, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
  }


# check_ar_lat
check_ar_lat <- function(dd){
  mm1<-lm(diff_lat ~  ar1_lat, dd,
        na.action = na.omit)
  mm2<-lm(diff_lat ~  ar1_lat + ar2_lat ,
        dd, na.action = na.omit)
  mm3<-lm(diff_lat ~ ar1_lat + ar2_lat +
        ar3_lat, dd, na.action = na.omit)
  mm4<-lm(diff_lat ~  ar1_lat + ar2_lat +
          ar3_lat + ar4_lat, dd, na.action = na.omit)
  mm1 <- c(summary(mm1)$ adj.r.squared, AIC(mm1))
  mm2 <- c(summary(mm2)$ adj.r.squared, AIC(mm2))
  mm3 <- c(summary(mm3)$ adj.r.squared, AIC(mm3))
  mm4 <- c(summary(mm4)$ adj.r.squared, AIC(mm4))
  list(mm1,mm2,mm3,mm4)
  
  }


# Build tibble
m.tibble <- function(model,col1,col2,
                      species,response){
  columns <- anova(model)[c(col1:col2),c(1:5)]
  Explanatory <- rownames(columns)
  R_square <- summary(model)$adj.r
  tibble(Species = species, 
         Response = response,
         Explanatory, columns, R_square)
  }


```


# Cod, individual range size
fit 4 ar, choose best.
correlation test of fishing & temp
when highly correlated, fit in separate models.
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# Correlation between temp & TSB
cor.test(dd$s_tsb,dd$s_temp) # -0.44
cor.test(dd$s_fmor,dd$s_temp) # -0.3
cor.test(dd$s_fmor,dd$s_tsb) # 0.47

# 1 Fit model with tsb
mf.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length * s_tsb, dd)
vif(mf.cod.range)
summary(mf.cod.range)
anova(mf.cod.range)

mf.cod.range.tibble <- 
  m.tibble(mf.cod.range,6,8,"Atlantic cod","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length * s_temp, dd)
vif(mt)
step(mt)

mt.cod.range <- lm(diff_area ~ 
     ar1_area + ar2_area + ar3_area + ar4_area +
     log_cpue + Length , dd)
vif(mt.cod.range)
anova(mt.cod.range)
summary(mt.cod.range)

mt.cod.range.tibble <- 
  m.tibble(mt.cod.range,6,6,"Atlantic cod","range")

cod.range.tibble <- 
  rbind(mf.cod.range.tibble, mt.cod.range.tibble)     

#------------AR1----------------
# mf
mf.cod.range1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_tsb, dd)
vif(mf.cod.range1)
summary(mf.cod.range1)
anova(mf.cod.range1)

(mf.cod.range.tibble.ar <- 
  m.tibble(mf.cod.range1,2,5,"Atlantic cod","range"))

# mt
mt1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_temp, dd)
vif(mt1)
step(mt1)

mt.cod.range1 <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length , dd)
vif(mt.cod.range1)
anova(mt.cod.range1)
summary(mt.cod.range1)
(mt.cod.range.tibble.ar <- 
  m.tibble(mt.cod.range1,2,3,"Atlantic cod","range"))

# mm (fishing mortality)
mm.cod.range1 <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_fmor, dd)
vif(mm.cod.range1)
summary(mm.cod.range1)
anova(mm.cod.range1)



```


# Cod, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# Correlation between temp & TSB
## When highly correlated, fit seperate models
cor.test(cpue.length.year.ar$s_tsb,cpue.length.year.ar$s_temp)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
AIC(mf)
AIC(mf1)
AIC(mf2)
mf.cod.lon <- mf2

(mf.cod.lon.tibble <- 
  m.tibble(mf.cod.lon,5,5,"Atlantic cod","Lon"))


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
mt2 <- update(mt1,~.-s_temp)
anova(mt2)
summary(mt2)
mt.cod.lon <- mt2

(mt.cod.lon.tibble <- 
  m.tibble(mt.cod.lon,5,5,"Atlantic cod","Lon"))

cod.lon.tibble <- 
  rbind(mf.cod.lon.tibble, mt.cod.lon.tibble)       


#--------AR1
#mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
AIC(mfar)
AIC(mf1ar)
AIC(mf2ar)
mf.cod.lon <- mf2ar

(mf.cod.lon.tibble.ar <- 
  m.tibble(mf.cod.lon,2,2,"Atlantic cod","Lon"))

#mt
#@ Results different from AR4.
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.cod.lon <- mtar

(mt.cod.lon.tibble.ar <- 
  m.tibble(mt.cod.lon,2,4,"Atlantic cod","Lon"))

```


# Cod, latitudinal centroid
Not include log_cpue at the global model 
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Atlantic cod")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)

# Correlation between temp & TSB
cor.test(cpue.length.year.ar$s_tsb,cpue.length.year.ar$s_temp)

# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)
step(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf.cod.lat <- mf1

mf.cod.lat.tibble <- m.tibble(mf.cod.lat,5,6,"Atlantic cod","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)

vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.cod.lat <- mt1

mt.cod.lat.tibble <- 
  m.tibble(mt.cod.lat,5,6,"Atlantic cod","Lat")


#----------AR1
# mf
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)
step(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf.cod.lat.ar <- mf1ar

(mf.cod.lat.tibble.ar <- m.tibble(mf.cod.lat.ar,2,3,"Atlantic cod","Lat"))

# mt
mtar <- lm(diff_lat ~ 
     ar1_lat +
     Length * s_temp, dd, na.action = na.omit)

vif(mtar)
summary(mtar)
anova(mtar)
mt1ar <- update(mtar,~.-Length:s_temp)
anova(mtar,mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.cod.lat.ar <- mt1ar

(mt.cod.lat.tibble.ar <- 
  m.tibble(mt.cod.lat.ar,2,3,"Atlantic cod","Lat"))

```


# Haddock, individual range size
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# Correlation between temp & TSB
cor.test(dd$s_tsb,dd$s_temp) # -0.33
cor.test(dd$s_fmor,dd$s_temp) # -0.32
cor.test(dd$s_fmor,dd$s_tsb) # 0.52

# 1 Fit model with tsb
mf <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length * s_tsb, dd)
summary(mf)
anova(mf)
step(mf)

mf1 <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_tsb, dd)
anova(mf1)
summary(mf1)
vif(mf1)
mf.had.range <- mf1

mf.had.range.tibble <- 
  m.tibble(mf.had.range,4,5,"Haddock","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_temp, dd)
anova(mt)
vif(mt)
step(mt)

mt1 <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1)
anova(mt1)
summary(mt1)
mt.had.range <- mt1


mt.had.range.tibble <- 
  m.tibble(mt.had.range,4,5,"Haddock","range")

had.range.tibble <- 
  rbind(mf.had.range.tibble, mt.had.range.tibble)     

#----------AR
# mf
mfar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_tsb, dd)
summary(mfar)
anova(mfar)
step(mfar)

mf1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_tsb, dd)
anova(mf1ar)
summary(mf1ar)
vif(mf1ar)
mf.had.range.ar <- mf1ar

(mf.had.range.tibble.ar <- 
  m.tibble(mf.had.range.ar,2,4,"Haddock","range"))


# mt
mtar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_temp, dd)
anova(mtar)
vif(mtar)
step(mtar)

mt1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.had.range.ar <- mt1ar


(mt.had.range.tibble.ar <- 
  m.tibble(mt.had.range.ar,2,4,"Haddock","range"))

# mm
mmar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_fmor, dd)
summary(mmar)
anova(mmar)
step(mmar)

```


# Haddock, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
AIC(mf)
AIC(mf1)
AIC(mf2)
mf.had.lon <- mf2

mf.had.lon.tibble <- 
  m.tibble(mf.had.lon,5,5,"Haddock","Lon")


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.had.lon <- mt1

mt.had.lon.tibble <- 
  m.tibble(mt.had.lon,5,6,"Haddock","Lon")

had.lon.tibble <- 
  rbind(mf.had.lon.tibble, mt.had.lon.tibble)       

#---------AR
# mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
mf.had.lon.ar <- mf2ar

(mf.had.lon.tibble.ar <- 
  m.tibble(mf.had.lon.ar,2,2,"Haddock","Lon"))


# mt
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt1ar <- update(mtar,~.-Length:s_temp)
anova(mtar,mt1ar)
anova(mt1ar)
summary(mt1ar)
mt.had.lon.ar <- mt1ar

(mt.had.lon.tibble.ar <- 
  m.tibble(mt.had.lon.ar,2,3,"Haddock","Lon"))

```


# Haddock, latitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Haddock")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)


# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)


mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
mf2<- update(mf1,~.-s_tsb)
summary(mf2)
anova(mf2)
mf.had.lat <- mf2

mf.had.lat.tibble <- m.tibble(mf.had.lat,5,5,"Haddock","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt1 <- update(mt,~.-Length:s_temp)
anova(mt,mt1)
anova(mt1)
summary(mt1)
mt.had.lat <- mt1

mt.had.lat.tibble <- 
  m.tibble(mt.had.lat,5,6,"Haddock","Lat")
            
had.lat.tibble <- rbind(mf.had.lat.tibble,
                   mt.had.lat.tibble)       

#----------AR
# 1 Fit full model with tsb
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)


mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
mf2ar<- update(mf1ar,~.-s_tsb)
summary(mf2ar)
anova(mf2ar)
mf.had.lat.ar <- mf2ar

(mf.had.lat.tibble.ar <- m.tibble(mf.had.lat.ar,2,2,"Haddock","Lat"))


# 2 Fit full model with temp
#@ results different from AR4
#@ in summary, temp only influence large groups
mtar <- lm(diff_lat ~ 
     ar1_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.had.lat.ar <- mtar

(mt.had.lat.tibble.ar <- 
  m.tibble(mt.had.lat.ar,2,4,"Haddock","Lat"))

```


# Whiting, individual range size
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_range(dd)

# correlation
cor.test(dd$s_tsb,dd$s_temp) # -0.16
cor.test(dd$s_fmor,dd$s_temp) # -0.23
cor.test(dd$s_fmor,dd$s_tsb) # 0.67

# 1 Fit model with tsb
mf <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_tsb, dd)
summary(mf)
anova(mf)
step(mf)

mf1 <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_tsb, dd)
anova(mf1)
summary(mf1)
vif(mf1)
mf.whi.range <- mf1

mf.whi.range.tibble <- 
  m.tibble(mf.whi.range,4,5,"Whiting","range")


# 2 Fit full model with temp
mt <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length * s_temp, dd)
anova(mt)
vif(mt)
step(mt)

mt1 <- lm(diff_area ~ 
     ar1_area + ar2_area + 
     log_cpue + Length + s_temp , dd)
vif(mt1)
anova(mt1)
summary(mt1)
AIC(mt)
AIC(mt1)
anova(mt)
summary(mt)
mt.whi.range <- mt # include interaction term


mt.whi.range.tibble <- 
  m.tibble(mt.whi.range,4,6,"Whiting","range")

whi.range.tibble <- 
  rbind(mf.whi.range.tibble, mt.whi.range.tibble)     

#-----------AR
# mf
mfar <- lm(diff_area ~ 
     ar1_area +
     log_cpue + Length * s_tsb, dd)
summary(mfar)
anova(mfar)
step(mfar)

mf1ar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length + s_tsb, dd)
anova(mf1ar)
summary(mf1ar)
vif(mf1ar)
mf.whi.range.ar <- mf1ar

(mf.whi.range.tibble.ar <- 
  m.tibble(mf.whi.range.ar,2,4,"Whiting","range"))


# mt
mtar <- lm(diff_area ~ 
     ar1_area + 
     log_cpue + Length * s_temp, dd)
anova(mtar)
summary(mtar)
vif(mtar)
step(mtar)
mt.whi.range.ar <- mtar

mt.whi.range.tibble.ar <- 
  m.tibble(mt.whi.range.ar,2,5,"Whiting","range")


# mm
mm <- lm(diff_area ~ 
     ar1_area + ar2_area +
     log_cpue + Length + s_fmor, dd)
summary(mm)
anova(mm)


```


# Whiting, longitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_lon(dd)

# 1 Fit full model with tsb
mf <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)

mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
summary(mf1)
mf2 <- update(mf1,~.-s_tsb)
anova(mf2)
summary(mf2)
mf.whi.lon <- mf2

mf.whi.lon.tibble <- 
  m.tibble(mf.whi.lon,5,5,"Whiting","Lon")


# 2 Fit full model with temp
mt <- lm(diff_lon ~ 
     ar1_lon + ar2_lon + ar3_lon + ar4_lon +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)
mt.whi.lon <- mt

mt.whi.lon.tibble <- 
  m.tibble(mt.whi.lon,5,7,"Whiting","Lon")

whi.lon.tibble <- 
  rbind(mf.whi.lon.tibble, mt.whi.lon.tibble)  


#------------AR
# mf
mfar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)

mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar <- update(mf1ar,~.-s_tsb)
anova(mf2ar)
summary(mf2ar)
mf.whi.lon.ar <- mf2ar

(mf.whi.lon.tibble.ar <- 
  m.tibble(mf.whi.lon.ar,2,2,"Whiting","Lon"))


# mt
mtar <- lm(diff_lon ~ 
     ar1_lon + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)
mt.whi.lon.ar <- mtar

(mt.whi.lon.tibble.ar <- 
  m.tibble(mt.whi.lon.ar,2,4,"Whiting","Lon"))

```


# Whiting, latitudinal centroid
Not include log_cpue at the global model
```{r}

dd <- cpue.length.year.ar %>% 
  filter(Species == "Whiting")

# Check AR with full dataset using AIC and R2
check_ar_lat(dd)


# 1 Fit full model with tsb
mf <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mf)
anova(mf)


mf1 <- update(mf,~.-Length:s_tsb)
anova(mf,mf1)
anova(mf1)
mf2<- update(mf1,~.-s_tsb)
summary(mf2)
anova(mf2)
mf.whi.lat <- mf2

mf.whi.lat.tibble <- m.tibble(mf.whi.lat,5,5,"Whiting","Lat")


# 2 Fit full model with temp
mt <- lm(diff_lat ~ 
     ar1_lat + ar2_lat + ar3_lat + ar4_lat +
     Length * s_temp, dd, na.action = na.omit)
vif(mt)
summary(mt)
anova(mt)

mt.whi.lat <- mt

mt.whi.lat.tibble <- 
  m.tibble(mt.whi.lat,5,7,"Whiting","Lat")
            
whi.lat.tibble <- rbind(mf.whi.lat.tibble,
                   mt.whi.lat.tibble)       

#--------------AR
# mf
mfar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_tsb,dd,
     na.action = na.omit)
vif(mfar)
anova(mfar)


mf1ar <- update(mfar,~.-Length:s_tsb)
anova(mfar,mf1ar)
anova(mf1ar)
summary(mf1ar)
mf2ar<- update(mf1ar,~.-s_tsb)
summary(mf2ar)
anova(mf2ar)
mf.whi.lat.ar <- mf2ar

(mf.whi.lat.tibble.ar <- m.tibble(mf.whi.lat.ar,2,2,"Whiting","Lat"))


# mt
mtar <- lm(diff_lat ~ 
     ar1_lat + 
     Length * s_temp, dd, na.action = na.omit)
vif(mtar)
summary(mtar)
anova(mtar)

mt.whi.lat.ar <- mtar

(mt.whi.lat.tibble.ar <- 
  m.tibble(mt.whi.lat.ar,2,4,"Whiting","Lat"))
            
```

# Statistic summary AR1
```{r}

stat.summary.ar1 <-rbind(
mt.cod.range.tibble.ar,
mf.cod.range.tibble.ar,
mt.cod.lon.tibble.ar1,
mf.cod.lon.tibble.ar1,
mt.cod.lat.tibble.ar,
mf.cod.lat.tibble.ar,
mt.had.range.tibble.ar,
mf.had.range.tibble.ar,
mt.had.lon.tibble.ar,
mf.had.lon.tibble.ar,
mt.had.lat.tibble.ar,
mf.had.lat.tibble.ar,
mt.whi.range.tibble.ar,
mf.whi.range.tibble.ar,
mt.whi.lon.tibble.ar,
mf.whi.lon.tibble.ar,
mt.whi.lat.tibble.ar,
mf.whi.lat.tibble.ar
)

write.csv (stat.summary.ar1, file = "stat.summary.ar1.csv")

```


# Plot cod subarea model 
```{r}
dd
ggplot(dd, aes(y = Stan_SubArea_Length, x = s_tsb, color = Length))+
  geom_smooth(method = "lm", se =  F)+
  geom_point()+ xlim(2,-2)+
  scale_colour_viridis_d()+ theme

ggplot(dd, aes(y = Stan_SubArea_Length, 
               x = s_temp, color = Length))+
  geom_point()+ theme+
  scale_colour_viridis_d()+
  geom_smooth(method = "lm", se =  F,
              color = "black",lty = 2)
  

```




# Cod,distribution range_trials
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


# Plot non-transformed and transformed variables
## Response variable
plot(dd$Num_SubArea_Length ~ dd$Year)
plot(dd$Centroid_lon~ dd$Year)
plot(dd$Centroid_lat~ dd$Year)

## Predictor
### log transform cpue
plot(dd$CPUE_Length_Year ~ dd $Year)
plot(log(dd$CPUE_Length_Year) ~ dd $Year) 
plot(dd$Fishing_Mortality ~ dd$Year)
plot(dd$MeanBT_scale ~ dd$Year)
plot(dd$TSB_Tonnes ~ dd$Year)

## Transformed variables
plot(dd$Diff_Num_SubArea_Length ~ dd$Year)
plot(dd$Diff_Centroid_lon~ dd$Year)
plot(dd$Diff_Centroid_lat~ dd$Year)
plot(dd$CPUE_Length_Year_scale_log ~ dd $Year)
plot(dd$Fishing_Mortality_scale ~ dd$Year)
plot(dd$MeanBT_scale ~ dd$Year)
plot(dd$TSB_Tonnes_scale ~ dd$Year)

# 5 Check colinearity of predictors
dd <- dd %>% 
  ungroup() %>% 
  select(Year,Length, Diff_Num_SubArea_Length,
         Diff_Centroid_lon,Diff_Centroid_lat,
         CPUE_Length_Year_scale_log,
         Fishing_Mortality_scale,
         MeanBT_scale, TSB_Tonnes_scale) %>% 
  mutate_at("Length", as.factor)

pairs(dd[,6:7])
cor.test(dd$Diff_Centroid_lon,dd$MeanBT_scale)

library(PerformanceAnalytics)
chart.Correlation(dd[,3:9], histogram=TRUE, pch=19)
cor.test(dd$MeanBT_scale, dd$TSB_Tonnes_scale)
## The highest correlation coefficient isx ~0.5
## It seems that it is not too high, so I can still fit
## all predictors as its original forms.


m<- lm(Diff_Num_SubArea_Length ~ 
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale, dd)

anova(m)
library(car)
vif(m)

## vif of two predictors are at the border line,
## but it is still ok to fit the original form.

# 6 Fit AR and select best AR
## 6.1 acf of residuals of fitted full model

acf(resid(m)) # indicate AR1
acf(residuals(m),type = "partial",na.action = na.omit) #indicate AR1
library(astsa)

## 6.2 acf of response variable without predictors
acf(dd$Diff_Num_SubArea_Length, na.action = na.omit) #indicate AR1

m0 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit)
m1 <- gls(Diff_Num_SubArea_Length~Length,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=1))
m2 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=2))
m3 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=3))
m21 <- gls(Diff_Num_SubArea_Length~1,dd, na.action = na.omit,
          correlation =corARMA(form = ~Year|Length, p=2,q = 1))
acf(resid(m21))

anova(m0,m1,m2,m3,m21) # for AIC, AR2 seems to be the best

sarima(dd$Diff_Num_SubArea_Length,1,0,0) # AR1
sarima(dd$Diff_Num_SubArea_Length,2,0,0) # AR2 is better than AR1

sarima(dd$Diff_Num_SubArea_Length,2,0,0,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale,
               dd$MeanBT_scale))

sarima(dd$Diff_Num_SubArea_Length,2,1,1,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale,
               dd$MeanBT_scale))


# 7 Fit selected AR and all predictors
dd<- dd %>% 
  mutate_at("Year", as.numeric) %>% 
  mutate_at("Length", as.factor)


mf0<- gls(Diff_Num_SubArea_Length ~ 
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale, 
     dd, na.action = na.omit)

mf1_nogroup <- update(mf0,correlation = 
                corARMA(p = 1, q = 0))


mf1 <- update(mf0,correlation = 
                corARMA(form = ~ Year | Length , 
                        p = 1, q = 0))

mf2 <- update(mf0,correlation = corARMA(form = ~ Year | Length , p = 2, q = 0))


anova(mf0)
summary(mf0)
anova(mf1)
summary(mf1)
anova(mf2)
summary(mf2)
AIC(mf0,mf1,mf1_nogroup,mf2)


plot(resid(mf0),fitted(mf0))
plot(resid(mf1),fitted(mf1))
plot(resid(mf1_nogroup),fitted(mf1_nogroup))
plot(resid(mf2),fitted(mf2))


# 8 Parsimonious model
## 8.1 with AR1
anova(mf1)
mf1.1 <-update(mf1,~.- Length:MeanBT_scale)
anova(mf1.1)
mf1.2 <- update(mf1.1,~.-Length:TSB_Tonnes_scale)
anova(mf1.2)
mf1.3 <- update(mf1.2,~.-MeanBT_scale)
anova(mf1.3)

sarima(dd$Diff_Num_SubArea_Length,2,0,0,xreg = 
         cbind(dd$CPUE_Length_Year_scale_log, 
               dd$TSB_Tonnes_scale))

## 8.2 with AR2
anova(mf2)
mf2.1<-update(mf2,~.-Length:TSB_Tonnes_scale)
anova(mf2.1)
mf2.2 <- update(mf2.1,~.-TSB_Tonnes_scale)
anova(mf2.2)
mf2.3 <- update(mf2.2,~.-Length:MeanBT_scale)
anova(mf2.3)
mf2.4 <- update(mf2.3,~.-MeanBT_scale)
anova(mf2.4)
mf2.5 <- update(mf2.4,~.-CPUE_Length_Year_scale_log)
anova(mf2.5)
plot(mf.5)
AIC(mf0,mf1,mf1.1,mf1.2,mf1.3,mf2)
acf(resid(m1))
acf(dd$Diff_Num_SubArea_Length, na.action = na.omit)

dd10<- dd %>% 
  filter(Length =="10")

m<- lm(Diff_Num_SubArea_Length ~ Length,dd)
anova(m)
plot(dd$Length,dd$Diff_Num_SubArea_Length)

### Final model:mf1.3
anova(mf1.3)
summary(mf1.3)


plot(dd10$Num_SubArea_Length,dd10$lag_Num_SubArea_Length)
acf(dd10$Num_SubArea_Length)
acf(resid(mf1.3))


# Fit AR as predictor in lm model
dd1 <- dd %>% 
  filter(Length =="1")
dd2 <- dd %>% 
  filter(Length =="2")

mm1<-lm(Diff_Num_SubArea_Length ~ Length + lag_Num_SubArea_Length,dd)

mm2<-lm(Diff_Num_SubArea_Length ~ Length + lag_Num_SubArea_Length +
         lag2_Num_SubArea_Length,dd)

anova(mm1)  
AIC(mm1,mm2)
plot(mm1)
E <- acf(resid(lm))
coplot(resid(lm)~fitted(lm)|Length,)


plot(fitted(lm),resid(lm))
plot(dd$Length,dd$Stan_SubArea_Length)


# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.32
summary(mm3) # r2 = 0.38 
summary(mm4) # r2 = 0.39


m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

AIC(m)
anova(m)
plot(m)
acf(resid(m))
plot(dd$Stan_SubArea_Length~dd$TSB_Tonnes_scale)

# mf<- gls(Diff_Stan_SubArea_Length ~ 
#        CPUE_Length_Year_scale_log+
#        Length * TSB_Tonnes_scale +
#        Length * MeanBT_scale,
#        correlation = corARMA(form = ~ Year | Length , p = 3, q = 0), 
#      dd, na.action = na.omit)
# anova(mf)
# 
# acf(resid(mf))





# Check AR with individual length
dd5 <- dd %>% 
  filter(Length =="5")

mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd5, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd5,
         na.action = na.omit)

AIC(mm1)
AIC(mm2)
AIC(mm3)
AIC(mm4)
summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.32
summary(mm3) # r2 = 0.38 
summary(mm4) # r2 = 0.39

dd5 <- dd %>% 
  filter(Length =="19")
m5 <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length
#    lag2_Stan_SubArea_Length+
      #lag3_Stan_SubArea_Length 
#      lag4_Stan_SubArea_Length 
     #CPUE_Length_Year_scale_log +
      #TSB_Tonnes_scale +
      #MeanBT_scale,
      ,dd5)
acf(resid(m5))
AIC(m5)


m5 <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length+
 lag4_Stan_SubArea_Length 
     #CPUE_Length_Year_scale_log +
      #TSB_Tonnes_scale +
      #MeanBT_scale,
      ,dd5)



cor.test(dd$MeanBT, dd$TSB_Tonnes)

```



# Cod,Diff_Centroid_lon: 
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.29
summary(mm2) # r2 = 0.30
summary(mm3) # r2 = 0.317
summary(mm4) # r2 = 0.314
AIC(mm1) # 3261
AIC(mm2) # 3191
AIC(mm3) # 3120
AIC(mm4) # 3054

## From best to worst: mm3/mm4>mm2>mm1


#2 Check AR with length subset (Length = 0, 5, 15,19)
dd5 <- dd %>% 
  filter(Length =="19")


mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.28 # 0.18 # 0.37 # 0.37
summary(mm2) # r2 = 0.30 # 0.19 # 0.43 # 0.43
summary(mm3) # r2 = 0.33 # 0.19 # 0.46 # 0.46
summary(mm4) # r2 = 0.31 # 0.24 # 0.46 # 0.46

AIC(mm1) # 172 # 160 # 118 # 154
AIC(mm2) # 170 # 158 # 114 # 149
AIC(mm3) # 166 # 158 # 112 # 146
AIC(mm4) # 165 # 154 # 112 # 145

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3 > mm4/mm2 > mm1


# 3 Fit full model with best AR (AR3)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-TSB_Tonnes_scale)
anova(m4)
summary(m4) #r2=0.31
AIC(m4) #3120
# Double check AR
m5<- update(m4,~.-lag3_Centroid_lon)
m6 <- update(m5,~.-lag2_Centroid_lon)
summary(m5) # r2=0.30
summary(m6) # r2=0.29
AIC(m5) # AIC 3192
AIC(m6) # AIC 3261

# Final:m4 has min AIC,max R2
anova(m4)
summary(m4)
```


# Cod,Diff_Centroid_lat: 
```{r}

cpue.length.cod <-
  cpue.length.year %>% 
  filter(Species == "Atlantic cod")

dd <- cpue.length.cod


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.34
summary(mm2) # r2 = 0.38
summary(mm3) # r2 = 0.38
summary(mm4) # r2 = 0.38
AIC(mm1) # 2363
AIC(mm2) # 2259
AIC(mm3) # 2204
AIC(mm4) # 2165

## From best to worst: mm4>mm3>mm2>mm1


#2 Check AR with length subset (Length = 0, 5)
dd5 <- dd %>% 
  filter(Length =="5")


mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.29 # 0.18
summary(mm2) # r2 = 0.37 # 0.39
summary(mm3) # r2 = 0.38 # 0.39
summary(mm4) # r2 = 0.39 # 0.40

AIC(mm1) # 65.47 # 91
AIC(mm2) # 61.1 # 72
AIC(mm3) # 60.5 # 71
AIC(mm4) # 61.5 # 72

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3 > mm4> mm2 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale)
anova(m1)
m2 <- update(m1,~.-Length:TSB_Tonnes_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-CPUE_Length_Year_scale_log)
anova(m4) 
summary(m4) # 0.43
AIC(m4) # 1999

# 5 Double check AR
m5 <- update(m4,~.-lag3_Centroid_lat)
m6 <- update(m5,~.-lag2_Centroid_lat)
summary(m5) # 0.43
summary(m6) # 0.43
AIC(m5) # 2036
AIC(m6) # 2093


## final model: m4 same R2 min AIC
anova(m4)
summary(m4)
ggplot(dd,aes(x = TSB_Tonnes_scale, y = Centroid_lat))+
  geom_point()+
  facet_wrap("Length")


```

# Haddock, distribution range: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock

#1 Check AR with full dataset using AIC and R2
# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.18
summary(mm2) # r2 = 0.23
summary(mm3) # r2 = 0.23
summary(mm4) # r2 = 0.24
AIC(mm1) # -829
AIC(mm2) # -889
AIC(mm3) # -863
AIC(mm4) # -872

## Best : Not obvious, mm2 

#2 Check AR with length subset (Length = 0, 5, 15, )
dd5 <- dd %>% 
  filter(Length =="0")

mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd5, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.28 # 0.12 # 0.18
summary(mm2) # r2 = 0.29 # 0.15 # 0.19
summary(mm3) # r2 = 0.28 # 0.15 # 0.18
summary(mm4) # r2 = 0.30 # 0.25 # 0.18

AIC(mm1) # 2.1 # -75 # -74
AIC(mm2) # 4.9 # -73 # -70
AIC(mm3) # 7.6 # -68 # -66
AIC(mm4) # 8.7 # -70 # -62

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## Not clear, mm1


# 3 Fit full model with best AR 
## As AR 1-4 seems similar, fit AR4, then trimming 

m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-MeanBT_scale)
anova(m3)
m4 <- update(m3,~.-lag4_Stan_SubArea_Length)
anova(m4)
plot(m4)
AIC(m4) # -1296

# 5 Check other AR
m5 <- update(m4,~.-lag4_Stan_SubArea_Length)
m6 <- update(m5,~.-lag3_Stan_SubArea_Length)
m7 <- update(m6,~.-lag2_Stan_SubArea_Length)
m8 <- update(m7,~.-lag1_Stan_SubArea_Length)
AIC(m5) # -1296
AIC(m6) # -1319
AIC(m7) # -1231
AIC(m8) # -1231
## final model: m6 (AR2)
anova(m6)
summary(m6)
```

# Haddock,Diff_Centroid_lon: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.37
summary(mm2) # r2 = 0.40
summary(mm3) # r2 = 0.41
summary(mm4) # r2 = 0.41
AIC(mm1) # 2689
AIC(mm2) # 2593
AIC(mm3) # 2529
AIC(mm4) # 2451

## best: not clear, mm4


#2 Check AR with length subset (Length = 0, 15)
dd5 <- dd %>% 
  filter(Length =="0")


mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon,dd5,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd5,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd5,
         na.action = na.omit)


summary(mm1) # r2 = 0.61 # 0.34
summary(mm2) # r2 = 0.65 # 0.45
summary(mm3) # r2 = 0.64 # 0.56
summary(mm4) # r2 = 0.64 # 0.55

AIC(mm1) # 94
AIC(mm2) # 90
AIC(mm3) # 90
AIC(mm4) # 90

acf(resid(mm1))
acf(resid(mm2))
acf(resid(mm3))
acf(resid(mm4))

## mm3/mm4


# 3 Fit full model with AR4 as not clear which AR is best

m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
      lag4_Centroid_lon+
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale )
anova(m2)

# 5 Double check AR
m3 <- update(m2,~.-lag4_Centroid_lon)
m4 <- update(m3,~.-lag3_Centroid_lon)
m5 <- update(m4,~.-lag2_Centroid_lon)
m6 <- update(m5,~.-lag_Centroid_lon)
AIC(m2) # 2274
AIC(m3) # 2347 
AIC(m4) # 2409
AIC(m5) # 2497
AIC(m6)
## final model: m2 (AR4)
anova(m2)
summary(m2)

```

# Haddock,Diff_Centroid_lat: 
```{r}

cpue.length.haddock <-
  cpue.length.year %>% 
  filter(Species == "Haddock")

dd <- cpue.length.haddock


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.31
summary(mm2) # r2 = 0.35
summary(mm3) # r2 = 0.38
summary(mm4) # r2 = 0.36
AIC(mm1) # 1662
AIC(mm2) # 1582
AIC(mm3) # 1515
AIC(mm4) # 1478

## mm3/mm4


# #2 Check AR with length subset (Length = 0, 5)
# dd5 <- dd %>% 
#   filter(Length =="5")
# 
# 
# mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat+
#           lag4_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.29 # 0.18
# summary(mm2) # r2 = 0.37 # 0.39
# summary(mm3) # r2 = 0.38 # 0.39
# summary(mm4) # r2 = 0.39 # 0.40
# 
# AIC(mm1) # 65.47 # 91
# AIC(mm2) # 61.1 # 72
# AIC(mm3) # 60.5 # 71
# AIC(mm4) # 61.5 # 72
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))


# 3 Fit full model with highest AR

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
      lag4_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-Length:MeanBT_scale)
anova(m2)
m3 <- update(m2,~.- TSB_Tonnes_scale)
anova(m3)

# 5 Double check AR
m4 <- update(m3,~.-lag4_Centroid_lat)
m5 <- update(m4,~.-lag3_Centroid_lat)
m6 <- update(m5,~.-lag2_Centroid_lat)
m7 <- update(m6,~.-lag_Centroid_lat)

AIC(m3) # 1381
AIC(m4) # 1418
AIC(m5) # 1483
AIC(m6) # 1566
AIC(m7) # 1887

## m3 is the best (AR4)
anova(m3)
summary(m3)

```

# Whiting, distribution range: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting

#1 Check AR with full dataset using AIC and R2
# Use Stan_Num_SubArea_Length
mm1<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length,dd,
        na.action = na.omit)

mm2<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length,dd, na.action = na.omit)

mm3<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd,
         na.action = na.omit)

mm4<-lm(Diff_Stan_SubArea_Length ~ Length + lag_Stan_SubArea_Length+
          lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
          lag4_Stan_SubArea_Length,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.19
summary(mm2) # r2 = 0.18
summary(mm3) # r2 = 0.19
summary(mm4) # r2 = 0.19
AIC(mm1) # -976
AIC(mm2) # -951
AIC(mm3) # -930
AIC(mm4) # -918

## From best to worst: mm4

#2 Check AR with length subset (Length = 0, 5, 15, )
# dd5 <- dd %>% 
#   filter(Length =="15")
# 
# mm1<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length,dd5,
#         na.action = na.omit)
# 
# mm2<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length,dd5, na.action = na.omit)
# 
# mm3<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Stan_SubArea_Length ~ lag_Stan_SubArea_Length+
#           lag2_Stan_SubArea_Length+ lag3_Stan_SubArea_Length+
#           lag4_Stan_SubArea_Length,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.41 # 0.28 # 0.09
# summary(mm2) # r2 = 0.49 # 0.40 # 0.12
# summary(mm3) # r2 = 0.63 # 0.48 # 0.17
# summary(mm4) # r2 = 0.64 # 0.51 # 0.29
# 
# AIC(mm1) # -4.06 #-34.6 # -39
# AIC(mm2) # -8.2  # -40.8 # -37.30
# AIC(mm3) # -18.56  #-43.5 # -37.36
# AIC(mm4) # -16.8 # -42.1 # -40.18
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))

## mm3 > mm2/mm4 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Stan_SubArea_Length ~ 
     lag_Stan_SubArea_Length+
    lag2_Stan_SubArea_Length+
      lag3_Stan_SubArea_Length +
      lag4_Stan_SubArea_Length +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale )
anova(m1)
m2 <- update(m1,~.-Length:TSB_Tonnes_scale)
anova(m2)
m3 <- update(m2,~.-lag3_Stan_SubArea_Length)
anova(m3)
m4 <- update(m3,~.-lag4_Stan_SubArea_Length)
anova(m4)

# 5 Check other AR
m5 <- update(m4,~.-lag2_Stan_SubArea_Length)
m6 <- update(m5,~.-lag1_Stan_SubArea_Length)
AIC(m4) # -852
AIC(m5) # -849
AIC(m6) # -849

# Final m4 with lowest AIC
anova(m4)
summary(m4)

```

# Whiting,Diff_Centroid_lon: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lon ~ Length + lag_Centroid_lon+
          lag2_Centroid_lon+lag3_Centroid_lon+
          lag4_Centroid_lon,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.4
summary(mm2) # r2 = 0.4
summary(mm3) # r2 = 0.4
summary(mm4) # r2 = 0.4
AIC(mm1) # 2915
AIC(mm2) # 2859
AIC(mm3) # 2799
AIC(mm4) # 2738

## Best:mm4


#2 Check AR with length subset (Length = 0, 5, 15,19)
# dd5 <- dd %>% 
#   filter(Length =="19")
# 
# 
# mm1<-lm(Diff_Centroid_lon ~ lag_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon+lag3_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lon ~ lag_Centroid_lon+
#           lag2_Centroid_lon+lag3_Centroid_lon+
#           lag4_Centroid_lon,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.28 # 0.18 # 0.37 # 0.37
# summary(mm2) # r2 = 0.30 # 0.19 # 0.43 # 0.43
# summary(mm3) # r2 = 0.33 # 0.19 # 0.46 # 0.46
# summary(mm4) # r2 = 0.31 # 0.24 # 0.46 # 0.46
# 
# AIC(mm1) # 172 # 160 # 118 # 154
# AIC(mm2) # 170 # 158 # 114 # 149
# AIC(mm3) # 166 # 158 # 112 # 146
# AIC(mm4) # 165 # 154 # 112 # 145
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))

## mm3 > mm4/mm2 > mm1


# 3 Fit full model with highest AR


m <- lm(Diff_Centroid_lon ~ 
     lag_Centroid_lon+
    lag2_Centroid_lon+
      lag3_Centroid_lon +
      lag4_Centroid_lon +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:TSB_Tonnes_scale)
anova(m1)
m2 <- update(m1,~.-MeanBT_scale)
anova(m2)
m3 <- update(m2,~.-CPUE_Length_Year_scale_log)
anova(m3)
m4 <- update(m3,~.-TSB_Tonnes_scale)
anova(m4)

# 5 Double check AR
m5 <- update(m4,~.-lag4_Centroid_lon)
m6 <- update(m5,~.-lag3_Centroid_lon)
m7 <- update(m6,~.-lag2_Centroid_lon)
m8 <- update(m7,~.-lag_Centroid_lon)

AIC(m4) # 2686
AIC(m5) # 2747
AIC(m6) # 2804
AIC(m7) # 2859
summary(m4) # R2= 0.45
summary(m5) # r2 = 0.45
summary(m6) # r2 = 0.44
summary(m7) # r2 = 0.44

# final: m4 (AR4) has the lowest AIC
anova(m4)
summary(m4)




```

# Whiting,Diff_Centroid_lat: 
```{r}

cpue.length.whiting <-
  cpue.length.year %>% 
  filter(Species == "Whiting")

dd <- cpue.length.whiting


#1 Check AR with full dataset using AIC and R2
# Use Diff_Centroid_lon

mm1<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat,dd,
         na.action = na.omit)

mm2<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat,dd,
         na.action = na.omit)

mm3<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat,dd,
         na.action = na.omit)

mm4<-lm(Diff_Centroid_lat ~ Length + lag_Centroid_lat+
          lag2_Centroid_lat+lag3_Centroid_lat+
          lag4_Centroid_lat,dd,
         na.action = na.omit)

summary(mm1) # r2 = 0.34
summary(mm2) # r2 = 0.35
summary(mm3) # r2 = 0.36
summary(mm4) # r2 = 0.37
AIC(mm1) # 2500
AIC(mm2) # 2436
AIC(mm3) # 2368
AIC(mm4) # 2315

## mm4 best


#2 Check AR with length subset (Length = 0, 5)
# dd5 <- dd %>% 
#   filter(Length =="5")
# 
# 
# mm1<-lm(Diff_Centroid_lat ~ lag_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm2<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm3<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# mm4<-lm(Diff_Centroid_lat ~ lag_Centroid_lat+
#           lag2_Centroid_lat+lag3_Centroid_lat+
#           lag4_Centroid_lat,dd5,
#          na.action = na.omit)
# 
# 
# summary(mm1) # r2 = 0.29 # 0.18
# summary(mm2) # r2 = 0.37 # 0.39
# summary(mm3) # r2 = 0.38 # 0.39
# summary(mm4) # r2 = 0.39 # 0.40
# 
# AIC(mm1) # 65.47 # 91
# AIC(mm2) # 61.1 # 72
# AIC(mm3) # 60.5 # 71
# AIC(mm4) # 61.5 # 72
# 
# acf(resid(mm1))
# acf(resid(mm2))
# acf(resid(mm3))
# acf(resid(mm4))
# 
# ## mm3 > mm4> mm2 > mm1


# 3 Fit full model with best AR (AR3)

m <- lm(Diff_Centroid_lat ~ 
     lag_Centroid_lat+
    lag2_Centroid_lat+
      lag3_Centroid_lat +
      lag4_Centroid_lat +
     CPUE_Length_Year_scale_log +
     Length * TSB_Tonnes_scale +
     Length * MeanBT_scale,dd)

anova(m)
plot(m) # Check QQ

# 4 Backward Parsimonious 
m1 <- update(m,~.-Length:MeanBT_scale)
anova(m1)
m2 <- update(m1,~.-MeanBT_scale )
anova(m2)
m3 <- update(m2,~.-Length:TSB_Tonnes_scale)
anova(m3)
m4 <- update(m3,~.-Length )
anova(m4)
m5 <- update(m4,~.-TSB_Tonnes_scale)
anova(m5)


# 5 Double check AR

m6 <- update(m5,~.-lag4_Centroid_lat)
m7 <- update(m6,~.-lag3_Centroid_lat)
m8 <- update(m7,~.-lag2_Centroid_lat)
m9 <- update(m8,~.-lag_Centroid_lat)

AIC(m5) # 2338
AIC(m6) # 2403
AIC(m7) # 2503
AIC(m8) # 2632
AIC(m9) # 2837

## final model: m5 (AR4) with lowest AIC
anova(m5)
summary(m5)

cpue.length.cod %>% 
  group_by(Year) %>%
  tally()
  
```


#----- fig S1 body size structure
```{r}

# q.limit has info of quantile length
q.limit

## function to plot all species
plot.age.structure <- function(species) {
  lim <- q.limit %>% filter(Species == species)
  cpue.lngt.yearqua.before.cut %>%
  filter(Species == species) %>%
  ggplot (aes(x = as.numeric(LngtClass), y = Denstiy_CPUE_Lngt_Yearqua))+
  geom_line()+
  facet_wrap(~YearQua, ncol = 9)+
    geom_vline(xintercept = lim$Lower_limit,
             linetype="dotted", 
             color = "blue", size=1)+
    geom_vline(xintercept = lim$Upper_limit,
             linetype="dotted", 
             color = "blue", size=1)+
    theme(axis.text.x = element_text(angle=45),
          panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    theme+
  ggtitle(species)+xlab("Length (cm)") +
    ylab("Abundance density (%)")+
    xlab("body length (mm)")
  }


plot.age.structure("Atlantic cod")
plot.age.structure("Haddock")
plot.age.structure("Whiting")


cpue.lngt.yearqua %>% 
  group_by(Species,Region) %>% 
  summarise(min_len = min(LngtClass),
            max_len = max(LngtClass))
  
  
```



#----- fig S4 fishing and temperature over time

```{r}
# TSB ~ Year
p1 <- cpue.year %>% 
  ggplot(aes(y = TSB_Tonnes / 1000000,
             x = Year,
             color = Species))+
           geom_point()+ geom_line()+
  xlab("Year")+ 
  ylab("Total stock biomass (million tonne)")+
   theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        legend.title = element_blank(),
        legend.position = c(.82,.82),
        strip.text.x = element_text(size = 11),
        legend.background = element_blank())+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14)) + ylim(0,2.5) +
  annotate("text", x=1977, y=2.5, label= "(a)") 

# Temperature ~ Year
p2 <- cpue.year %>% 
  ggplot(aes(y = MeanBT,
             x = Year))+
           geom_point()+ geom_line()+
  xlab("Year")+ 
  ylab(expression
       (Sea~bottom~temperature~(""^o~C)))+
   theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10),
        legend.title = element_blank(),
        #legend.position = c(.82,.82),
        strip.text.x = element_text(size = 11))+
  scale_x_continuous(breaks = seq(1977, 2019, by = 14)) + ylim(3,8)+
  annotate("text", x=1977, y=8, label= "(b)")

# Align two graphs
require(gridExtra)
grid.arrange(p1, p2, ncol=2)

```


#----- fig S7 distribtuion area change: stage based
```{r}
# replace with stage

cpue.length.year

juv_adu_fun <- function(species, group.at.maturity) {
  cpue.length.year %>% filter(Species == species) %>% 
    mutate_at("Length", as.numeric) %>% 
  mutate(Stage = replace(Length, Length < group.at.maturity,"juv")) %>% 
  mutate(Stage = replace(Stage, Length >= group.at.maturity, "adu")) 
    }

d1 <- juv_adu_fun("Atlantic cod", 7)
d2 <- juv_adu_fun("Haddock", 8)  
d3 <- juv_adu_fun("Whiting", 7)

cpue.length.year.stage <- rbind(d1,d2,d3)


# plot
plot_fun <- function(species){
  d1 <- cpue.length.year.stage %>% filter(Species == species) 
  ggplot(d1,
       aes(x = Year, y = Num_SubArea_Length, colour = Stage))+
  geom_point() +
  #geom_line(aes(colour = ))+
  geom_smooth(method='lm', formula= y~x, se = F)+
    scale_color_viridis_d(alpha = .5)+
    theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x=element_text(size = 10),
        axis.text.y = element_text(size = 10))+
    ylab("absolute number of occupied rectangles")+
    ggtitle(species)}
  

p1 <- plot_fun("Atlantic cod")
p2 <- plot_fun("Haddock")
p3 <- plot_fun("Whiting")


```
